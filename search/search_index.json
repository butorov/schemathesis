{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Schemathesis","text":"<p>Schemathesis automatically generates and runs API tests from your OpenAPI or GraphQL schema to find bugs and spec violations.</p> <p> Automatically finding specification violations and server errors </p> <p>Get Your API tested in 5 Minutes </p>"},{"location":"#why-schemathesis","title":"Why Schemathesis?","text":"<ul> <li>\ud83d\udcd1 Schema-Based Testing - Transform API documentation into a comprehensive test suite</li> <li>\ud83d\ude80 Zero Configuration - Begin testing immediately with a valid OpenAPI or GraphQL schema</li> <li>\u2699\ufe0f CI-Ready - Integrate API testing into existing pipelines without complex configuration</li> <li>\ud83d\udee1\ufe0f Effective Coverage - Find edge cases no manual testing could uncover</li> <li>\ud83d\udd2c Research-Backed: Recognized in academic research as a state-of-the-art API testing tool</li> </ul>      \"The tool is amazing as it can test negative scenarios instead of me and much faster!\"    \u2014 Lud\u011bk Nov\u00fd, JetBrains"},{"location":"#try-it","title":"Try It","text":"<pre><code>$ uvx schemathesis run http://example.schemathesis.io/openapi.json\n</code></pre> <p>For installing Schemathesis, we recommend using uv, a fast Python package installer and environment manager.</p>"},{"location":"#schema-support","title":"Schema Support","text":"<ul> <li>OpenAPI: 2.0 (Swagger), 3.0, and 3.1</li> <li>GraphQL: 2018 specification</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li> <p> Tutorial</p> <p>Introduction to Schemathesis:</p> <ul> <li> Quick Start Guide</li> <li> Tutorial for CLI &amp; pytest</li> </ul> </li> <li> <p> How-To Guides</p> <p>Practical guides for using Schemathesis:</p> <ul> <li> CI / CD Integration</li> <li> Extending Schemathesis</li> <li> More...</li> </ul> </li> <li> <p> Explanations</p> <p>Diving deep into how Schemathesis works:</p> <ul> <li> Testing Workflow</li> <li> Data Generation</li> <li> Checks</li> </ul> </li> <li> <p> API Reference</p> <p>Technical API reference:</p> <ul> <li> Command-Line Interface</li> <li> Python API</li> <li> Configuration File</li> </ul> </li> </ul>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li> <p>Resources \u2014 Community articles, videos, and tutorials</p> </li> <li> <p>Troubleshooting \u2014 Solve common issues</p> </li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#what-kind-of-data-does-schemathesis-generate","title":"What kind of data does Schemathesis generate?","text":"<p>Schemathesis generates three types of test data:</p> <ul> <li>Explicit examples directly from your API schema (when available)</li> <li>Valid data that conforms to your API schema's constraints</li> <li>Invalid data that deliberately violates schema constraints (when using negative testing modes, currently limited to OpenAPI tests)</li> </ul> <p>For OpenAPI schemas, the data generation covers all JSON Schema data types and their combinations, with varying complexity and edge cases. For GraphQL, Schemathesis generates valid queries based on the schema structure.</p> <p>While Schemathesis attempts to generate realistic data based on schema constraints, it may occasionally generate data that is rejected by your application due to validation rules not expressed in the schema.</p>"},{"location":"faq/#what-types-of-api-issues-can-schemathesis-find","title":"What types of API issues can Schemathesis find?","text":"<p>Schemathesis identifies problems in three main categories:</p> <p>API Contract Violations</p> <ul> <li>Responses not matching documented schemas</li> <li>Undocumented status codes</li> <li>Missing or incorrect content types</li> </ul> <p>Implementation Flaws</p> <ul> <li>Server errors (5xx responses)</li> <li>Data validation issues (accepting invalid data or rejecting valid data)</li> <li>Authentication bypasses</li> </ul> <p>Stateful Behavior Issues</p> <ul> <li>Resources accessible after deletion</li> <li>Resources unavailable after creation</li> </ul>"},{"location":"faq/#how-should-i-run-schemathesis","title":"How should I run Schemathesis?","text":"<p>Schemathesis can be run in two primary ways:</p> <ul> <li>As a CLI tool: Ideal for testing APIs built in any programming language. The CLI offers the most complete feature set, including all test phases, comprehensive reporting, and stateful testing. This is the recommended approach for most users.</li> <li>As a Python library: Useful for Python applications where you want to integrate with existing pytest test suites. While the Python API has some limitations compared to the CLI due to pytest constraints, it offers more opportunities for customization and extension.</li> </ul> <p>Choose the CLI approach for the most comprehensive testing capabilities and language-agnostic testing. Use the Python library when you need direct programmatic control or tight integration with your Python testing infrastructure.</p>"},{"location":"faq/#what-if-my-application-doesnt-have-an-api-schema","title":"What if my application doesn't have an API schema?","text":"<p>If your API doesn't have a schema, you have several options:</p> <ol> <li> <p>Generate a schema: Use tools like flasgger (Python), GrapeSwagger (Ruby), or Swashbuckle (ASP.NET) to automatically generate an initial schema from your code.</p> </li> <li> <p>Write a minimal schema: Create a basic schema manually covering just the endpoints you want to test first, then expand it over time.</p> </li> <li> <p>Use schema inference tools: Some third-party tools can observe API traffic and generate a schema based on observed requests and responses.</p> </li> </ol> <p>Starting with an imperfect schema is fine - Schemathesis can help you refine it by identifying inconsistencies between your schema and implementation.</p>"},{"location":"faq/#how-long-does-it-usually-take-for-schemathesis-to-test-an-api","title":"How long does it usually take for Schemathesis to test an API?","text":"<p>Testing duration depends on several factors:</p> <ul> <li>API complexity: More endpoints and parameters mean more tests</li> <li>Test configuration: Settings like <code>--max-examples</code> directly affect the number of tests generated</li> <li>Response time: Slower APIs take longer to test</li> <li>Schema complexity: Complex schemas may require more tests to achieve good coverage</li> </ul> <p>In practice, testing typically takes from a few seconds to a few minutes for most APIs. Very large or complex APIs might take longer, especially with high <code>--max-examples</code> settings or when using stateful testing.</p> <p>You can control testing duration by adjusting the <code>--max-examples</code> parameter and by enabling parallel testing with the <code>--workers</code> option.</p>"},{"location":"faq/#how-is-schemathesis-different-from-other-api-testing-tools","title":"How is Schemathesis different from other API testing tools?","text":"<p>Schemathesis differs from other API testing tools in several key ways:</p> <ul> <li> <p>Property-based testing: Tests API properties (like \"all responses should match their schema\") rather than specific input-output pairs, automatically exploring the input space to find violations.</p> </li> <li> <p>Stateful testing: Schemathesis can test sequences of API calls to find issues that only appear in specific request orders.</p> </li> <li> <p>Failure minimization: When issues are found, Schemathesis automatically simplifies the failing test case to the minimal example that reproduces the problem.</p> </li> <li> <p>Schema-first workflow: While tools like Postman or Insomnia focus on manual request creation, Schemathesis derives all test cases directly from your API specification.</p> </li> </ul> <p>Compared to tools like Dredd, Schemathesis focuses more on finding unexpected edge cases through property-based testing rather than verifying documented examples.</p>"},{"location":"faq/#what-are-the-known-limitations-of-schemathesis","title":"What are the known limitations of Schemathesis?","text":"<p>Schemathesis has the following known limitations:</p>"},{"location":"faq/#schema-processing-limitations","title":"Schema Processing Limitations","text":"<ul> <li>Recursive References:   Schemathesis handles most recursive schemas by cutting recursion at a defined depth. However, in a very small fraction of cases (approximately 25 out of over 100,000 schemas tested), complex recursive patterns involving multiple reference hops may cause errors. For more details, see GitHub issue #947.</li> </ul>"},{"location":"faq/#graphql-limitations","title":"GraphQL Limitations","text":"<ul> <li>Negative Testing:   Schemathesis does not support generating invalid inputs for GraphQL endpoints. The <code>--mode negative</code> and <code>--mode all</code> options are applicable only to OpenAPI schemas.</li> </ul> <p>If you encounter issues not listed here, please report them on our GitHub issues page.</p>"},{"location":"quick-start/","title":"Getting Started with Schemathesis","text":"<p>Schemathesis automatically generates and runs API tests from your OpenAPI or GraphQL schema to find bugs and spec violations.</p>"},{"location":"quick-start/#what-is-schemathesis","title":"What is Schemathesis?","text":"<p>Schemathesis is a property-based testing tool that:</p> <ul> <li>Uses your API schema to generate test cases automatically</li> <li>Validates responses against schema definitions</li> <li>Finds edge cases and bugs without manual test writing</li> <li>Works with OpenAPI (Swagger) and GraphQL schemas</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#using-uv-recommended","title":"Using uv (recommended)","text":"<p>uv is a fast Python package installer and environment manager:</p> <pre><code>$ uv pip install schemathesis\n</code></pre>"},{"location":"quick-start/#run-without-installing","title":"Run without installing","text":"<p>uvx (part of the uv ecosystem) lets you run Schemathesis directly without installation:</p> <pre><code>$ uvx schemathesis run https://example.schemathesis.io/openapi.json\n</code></pre>"},{"location":"quick-start/#using-docker","title":"Using Docker","text":"<pre><code>$ docker pull schemathesis/schemathesis:stable\n$ docker run schemathesis/schemathesis:stable --version\n</code></pre> <p>Verify your installation:</p> <pre><code>$ schemathesis --version\n# or using the shorter command alias\n$ st --version\nSchemathesis 4.0.0\n</code></pre>"},{"location":"quick-start/#testing-a-sample-api","title":"Testing a Sample API","text":"<p>Let's run a basic test against an example API:</p> <pre><code>$ st run https://example.schemathesis.io/openapi.json\n</code></pre> <p>This single command:</p> <ul> <li>Loads the API schema</li> <li>Generates test cases based on schema definitions</li> <li>Sends requests to test endpoints</li> <li>Validates responses with various checks</li> </ul> <p>You should see output similar to this:</p> <pre><code>Schemathesis 4.0.0\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n \u2705  Loaded specification from https://schemathesis.io/openapi.json (in 0.32s)\n\n     Base URL:         http://127.0.0.1/api\n     Specification:    Open API 3.0.2\n     Operations:       1 selected / 1 total\n\n \u2705  API capabilities:\n\n     Supports NULL byte in headers:    \u2718\n\n \u23ed   Examples (in 0.00s)\n\n     \u23ed  1 skipped\n\n \u274c  Coverage (in 0.00s)\n\n     \u274c 1 failed\n\n \u274c  Fuzzing (in 0.00s)\n\n     \u274c 1 failed\n\n=================================== FAILURES ===================================\n_________________________________ GET /success _________________________________\n1. Test Case ID: &lt;PLACEHOLDER&gt;\n\n- Response violates schema\n\n    {} is not of type 'integer'\n\n    Schema:\n\n        {\n            \"type\": \"integer\"\n        }\n\n    Value:\n\n        {}\n\n- Missing Content-Type header\n\n    The following media types are documented in the schema:\n    - `application/json`\n\n[200] OK:\n\n    `{}`\n\nReproduce with:\n\n    curl -X GET http://127.0.0.1/api/success\n\n=================================== SUMMARY ====================================\n\nAPI Operations:\n  Selected: 1/1\n  Tested: 1\n\nTest Phases:\n  \u2705 API probing\n  \u23ed  Examples\n  \u274c Coverage\n  \u274c Fuzzing\n  \u23ed  Stateful (not applicable)\n\nFailures:\n  \u274c Response violates schema: 1\n  \u274c Missing Content-Type header: 1\n\nTest cases:\n  N generated, N found N unique failures\n\nSeed: 42\n\n============================= 2 failures in 1.00s ==============================\n</code></pre>"},{"location":"quick-start/#understanding-test-results","title":"Understanding Test Results","text":"<p>In this test:</p> <ol> <li>Schemathesis found that the API endpoint's response didn't match what was defined in the schema</li> <li>The endpoint was supposed to return an integer, but returned an empty object (<code>{}</code>) instead</li> <li>The response was also missing a required Content-Type header</li> </ol> <p>For each issue found, Schemathesis provides:</p> <ul> <li>An explanation of what went wrong</li> <li>The expected vs. actual values</li> <li>A curl command to help you reproduce the issue</li> </ul>"},{"location":"quick-start/#common-issues-and-troubleshooting","title":"Common Issues and Troubleshooting","text":"<p>Schemathesis identifies these common categories of API problems:</p>"},{"location":"quick-start/#api-contract-violations","title":"API Contract Violations","text":"<ul> <li>Schema violations: Response bodies that don't match the defined schema</li> <li>Status code issues: Unexpected or undocumented HTTP status codes</li> <li>Header problems: Missing or incorrect response headers</li> </ul>"},{"location":"quick-start/#implementation-flaws","title":"Implementation Flaws","text":"<ul> <li>Server errors: 5xx responses indicating server-side problems</li> <li>Data validation issues: APIs accepting invalid data or rejecting valid data</li> <li>Security concerns: Potential authentication bypasses</li> </ul>"},{"location":"quick-start/#stateful-behavior-issues","title":"Stateful Behavior Issues","text":"<ul> <li>Resource state problems: Resources inaccessible after creation or accessible after deletion</li> </ul> <p>When you encounter these issues:</p> <ol> <li>Use the provided curl command to reproduce and verify the problem</li> <li>Check your API implementation against the schema definition</li> <li>Determine if the issue is in the schema (incorrect definition) or the API (incorrect implementation)</li> <li>For schema issues, update your schema definition</li> <li>For API issues, modify your implementation to comply with the schema</li> </ol>"},{"location":"quick-start/#testing-your-own-api","title":"Testing Your Own API","text":"<p>To test your own API:</p> <ol> <li>Make sure your API is running</li> <li>Run Schemathesis against your schema:</li> </ol> <pre><code># If your API serves its own schema\n$ st run https://your-api.com/openapi.json\n\n# If you have a local schema file\n$ st run ./openapi.yaml --url https://your-api.com\n</code></pre> <p>That's it! Schemathesis will automatically generate test cases based on your schema and identify any server errors or compliance issues.</p>"},{"location":"quick-start/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Testing Workflow - Understand how Schemathesis works</li> <li>Command-Line Interface - Learn all available CLI options</li> <li>Authentication - Configure tests for protected APIs</li> <li>Continuous Integration - Automate API testing in your CI pipeline</li> </ul>"},{"location":"resources/","title":"External Resources","text":"<p>This page collects articles, papers, videos, and tutorials about Schemathesis written by the community. These resources provide additional perspectives, use cases, and implementation examples.</p>"},{"location":"resources/#papers","title":"Papers","text":"<ul> <li> <p>Testing RESTFul APIs: A Survey by Golmohammadi, et al.</p> <ul> <li> <p>Description: Academic review of state-of-the-art API testing tools including Schemathesis.</p> </li> <li> <p>Date: 24 Nov 2023</p> </li> </ul> </li> <li> <p>Deriving Semantics-Aware Fuzzers from Web API Schemas by @Zac-HD and @Stranger6667</p> <ul> <li> <p>Description: Research paper exploring the automation of API testing through semantics-aware fuzzing. Presented at ICSE 2022.</p> </li> <li> <p>Date: 20 Dec 2021</p> </li> </ul> </li> </ul>"},{"location":"resources/#tutorials","title":"Tutorials","text":"<ul> <li> <p>Automated REST API fuzzing using Schemathesis by @RafDevX and @sofiaedv at KTH Royal Institute of Technology</p> <ul> <li> <p>Description: Hands-on tutorial on fuzzing REST APIs with Schemathesis from the course DD2482 Automated Software Testing and DevOps</p> </li> <li> <p>Date: 15 Oct 2023</p> </li> </ul> </li> </ul>"},{"location":"resources/#articles","title":"Articles","text":"<ul> <li> <p>Create a Cracker of an Open API Contract with VS Code, Spectral, Prism and Schemathesis by @dataGriff</p> <ul> <li> <p>Description: Detailed walkthrough of contract-first API design and testing workflow.</p> </li> <li> <p>Date: 22 Dec 2023</p> </li> </ul> </li> <li> <p>Boost Your FastAPI Reliability with Schemathesis Automated Testing by @Jeremy</p> <ul> <li> <p>Description: Implementation guide for Schemathesis testing in FastAPI projects.</p> </li> <li> <p>Date: 17 Jul 2023</p> </li> </ul> </li> <li> <p>Implementing Schemathesis at PayLead by J\u00e9r\u00e9my Pelletier at PayLead</p> <ul> <li> <p>Description: Case study including custom hooks, stateful testing, and CI/CD integration.</p> </li> <li> <p>Date: 29 May 2023</p> </li> </ul> </li> <li> <p>Auto-Generating &amp; Validating OpenAPI Docs in Rust: A Streamlined Approach with Utoipa and Schemathesis by identeco</p> <ul> <li> <p>Description: Integration of OpenAPI doc generation with Utoipa and validation with Schemathesis in Rust applications.</p> </li> <li> <p>Date: 01 Jun 2023</p> </li> </ul> </li> <li> <p>Testing APIFlask with schemathesis by @pamelafox</p> <ul> <li> <p>Description: Technical guide for testing APIFlask applications using Schemathesis.</p> </li> <li> <p>Date: 27 Feb 2023</p> </li> </ul> </li> <li> <p>Using Hypothesis and Schemathesis to Test FastAPI by @amalshaji</p> <ul> <li> <p>Description: Technical overview of property-based testing in FastAPI with Hypothesis and Schemathesis.</p> </li> <li> <p>Date: 06 Sep 2022</p> </li> </ul> </li> <li> <p>How to use Schemathesis to test Flask API in GitHub Actions by @lina-is-here</p> <ul> <li> <p>Description: Implementation guide for Schemathesis with Flask API in GitHub Actions.</p> </li> <li> <p>Date: 04 Aug 2022</p> </li> </ul> </li> <li> <p>Using API schemas for property-based testing (in Russian) by @Stranger6667</p> <ul> <li> <p>Description: Technical article covering Schemathesis for property-based API testing.</p> </li> <li> <p>Date: 07 Sep 2021</p> </li> </ul> </li> <li> <p>Schemathesis: property-based testing for API schemas by @Stranger6667</p> <ul> <li> <p>Description: Introduction to the concepts behind Schemathesis and property-based testing for APIs.</p> </li> <li> <p>Date: 26 Nov 2019</p> </li> </ul> </li> </ul>"},{"location":"resources/#videos","title":"Videos","text":"<ul> <li> <p>API Fuzzing: What it is and why you should use it by Jos\u00e9 Haro Peralta</p> <ul> <li> <p>Description: Technical overview and demonstration of Schemathesis capabilities.</p> </li> <li> <p>Date: 14 Feb 2023</p> </li> </ul> </li> <li> <p>Automated Testing with Schemathesis with video tutorial by Red Hat</p> <ul> <li> <p>Description: Hands-on tutorial for implementing API testing with Schemathesis.</p> </li> <li> <p>Date: 09 Feb 2023</p> </li> </ul> </li> <li> <p>Effective API schemas testing from DevConf.cz by @Stranger6667</p> <ul> <li> <p>Description: Technical presentation on Schemathesis for property-based API schema testing.</p> </li> <li> <p>Date: 24 Mar 2021</p> </li> </ul> </li> <li> <p>API-schema-based testing with schemathesis from EuroPython 2020 by @hultner</p> <ul> <li> <p>Description: Technical introduction to property-based API testing with Schemathesis.</p> </li> <li> <p>Date: 23 Jul 2020 </p> </li> </ul> </li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"tutorial/","title":"Schemathesis Tutorial","text":"<p>Estimated time: 15-20 minutes</p> <p>This tutorial walks you through a complete API testing workflow with Schemathesis using a booking API. You'll see how property-based testing automatically finds bugs that manual testing typically misses.</p> <p>What you'll accomplish</p> <p>By the end, you'll catch API bugs automatically and integrate Schemathesis into your development workflow.</p> <p>If you're new to Schemathesis, check the Quick Start Guide first.</p>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Git - to clone the example API repository</p> </li> <li> <p>Docker Compose - Install Docker Desktop which includes Docker Compose</p> </li> <li> <p>uv - Python package manager that allows running Schemathesis without installation using <code>uvx</code></p> </li> <li> <p>curl (optional) - for reproducing API failures manually</p> </li> </ul> <p>Verify your setup:</p> <pre><code>git --version\ndocker compose version\nuv --version\ncurl --version  # optional\n</code></pre>"},{"location":"tutorial/#api-under-test","title":"API under test","text":"<p>We'll test an example booking API that handles hotel reservations - creating bookings and retrieving guest information. This is a sample API designed to demonstrate common validation scenarios.</p> <p>The API lives in the Schemathesis repository:</p> <pre><code>git clone https://github.com/schemathesis/schemathesis.git\ncd schemathesis/examples/basic\ndocker compose up -d\n</code></pre> <p>Verify the API is running</p> <p>Open http://localhost:8080/docs - you should see the interactive API documentation.</p> <p>Authentication token</p> <p>The API requires bearer token authentication. Use: <code>secret-token</code></p>"},{"location":"tutorial/#first-test-run","title":"First Test Run","text":"<p>Schemathesis automatically tests all API operations with various test types to find edge cases:</p> <pre><code>uvx schemathesis run http://127.0.0.1:8080/openapi.json \\\n  --header 'Authorization: Bearer secret-token' \\\n  --output-sanitize false\n</code></pre> <p>Key findings from the output:</p> <p>Bug discovered</p> <pre><code>\u274c Server error: 1\n\u274c Undocumented HTTP status code: 1\n\nReproduce with:\ncurl -X POST -H 'Authorization: Bearer secret-token' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"guest_name\": \"00\", \"nights\": 1, \"room_type\": \"\"}' \\\n  http://127.0.0.1:8080/bookings\n</code></pre> <p>Empty <code>room_type</code> causes a 500 error because the pricing logic can't handle unexpected values.</p> <p>Run the provided <code>curl</code> command to reproduce this failure.</p>"},{"location":"tutorial/#reporting","title":"Reporting","text":"<p>Schemathesis can export test results in multiple formats for integration with existing tools and CI/CD pipelines. Let's generate a JUnit report that can be imported into Jenkins, GitLab CI, or other test management systems:</p> <pre><code>uvx schemathesis run http://127.0.0.1:8080/openapi.json \\\n  --header 'Authorization: Bearer secret-token' \\\n  --output-sanitize false \\\n  --report junit\n</code></pre> <p>This creates a <code>junit.xml</code> file in the <code>schemathesis-report</code> directory containing structured test results. The JUnit format includes:</p> <ul> <li>Test case details and execution times</li> <li>Failure descriptions with reproduction steps</li> </ul> <p>You can customize the output location using <code>--report-junit-path</code> or change the report directory with <code>--report-dir</code>. Other available formats include VCR cassettes (<code>--report vcr</code>) and HAR files (<code>--report har</code>) for detailed HTTP traffic analysis.</p>"},{"location":"tutorial/#fixing-the-bug","title":"Fixing the bug","text":"<p>Root cause</p> <p>The schema allows any string for <code>room_type</code>, but our pricing logic only handles specific values.</p> <p>Fix: Constrain room types in the schema</p> Before (broken)After (fixed) <pre><code>class BookingRequest(BaseModel):\n    room_type: str  # Any string allowed!\n</code></pre> <pre><code>from enum import Enum\n\nclass RoomType(str, Enum):\n    standard = \"standard\"\n    deluxe = \"deluxe\" \n    suite = \"suite\"\n\nclass BookingRequest(BaseModel):\n    room_type: RoomType  # Only valid values\n</code></pre> <p>Don't forget to restart:</p> <pre><code>docker compose restart\n</code></pre>"},{"location":"tutorial/#re-running-the-tests","title":"Re-running the tests","text":"<p>Now let's verify our fix by re-running the tests. Focus on the operation you just fixed:</p> <pre><code>uvx schemathesis run http://127.0.0.1:8080/openapi.json \\\n  --header 'Authorization: Bearer secret-token' \\\n  --output-sanitize false \\\n  --include-operation-id create_booking_bookings_post\n</code></pre> <p>Expected result</p> <p>You should see no failures for the <code>POST /bookings</code> operation. The 500 error is now prevented.</p> <p>Operation ID explained</p> <p>FastAPI generates operation IDs automatically. You can find them in the OpenAPI schema or API docs.</p> <p>The <code>--include-operation-id</code> option targets only the specific operation we fixed, making the test run faster during development. You can also filter by HTTP method (<code>--include-method POST</code>) or path patterns (<code>--include-path /bookings</code>).</p>"},{"location":"tutorial/#generating-more-test-cases","title":"Generating more test cases","text":"<p>Want to find more bugs?</p> <p>By default, Schemathesis stops at the first failure per operation and runs a limited number of test cases. Let's be more thorough:</p> <pre><code>uvx schemathesis run http://127.0.0.1:8080/openapi.json \\\n  --header 'Authorization: Bearer secret-token' \\\n  --output-sanitize false \\\n  --max-examples 500 \\\n  --continue-on-failure\n</code></pre> <p><code>--max-examples 500</code> generates more test cases per operation, increasing the chance of finding edge cases that smaller test runs might miss.</p> <p><code>--continue-on-failure</code> prevents Schemathesis from stopping at the first failure, allowing it to discover multiple issues on the same API operation in a single run.</p> <p>These options are particularly valuable when:</p> <ul> <li>Preparing for production releases</li> <li>Testing complex validation logic</li> </ul> <p>The trade-off is longer execution time, but you'll get more chances to find bugs.</p>"},{"location":"tutorial/#configuration-file","title":"Configuration File","text":"<p>Tired of long command lines?</p> <p>Instead of repeating long commands, save your settings once and reuse them across your team.</p> <p>Create <code>schemathesis.toml</code> in your project:</p> <pre><code># Core settings from our previous commands\nheaders = { Authorization = \"Bearer ${API_TOKEN}\" }\ncontinue-on-failure = true\n\n[output.sanitization]\nenabled = false\n\n[generation] \nmax-examples = 500\n\n[reports.junit]\nenabled = true\n</code></pre> <p>Environment variables</p> <pre><code>export API_TOKEN=secret-token\n</code></pre> <p>Now run with just: <pre><code>uvx schemathesis run http://127.0.0.1:8080/openapi.json\n</code></pre></p> <p>Schemathesis automatically loads <code>schemathesis.toml</code> from the current directory or project root. You can specify a custom configuration file:</p> <pre><code>uvx schemathesis --config-file path/to/config.toml run http://...\n</code></pre> <p>Configuration precedence</p> <p>CLI options override config file settings, so you can still adjust settings temporarily.</p>"},{"location":"tutorial/#whats-next","title":"What's next?","text":"<p>You've learned the core workflow!</p> <ul> <li>\u2705 Find bugs automatically with property-based testing</li> <li>\u2705 Focus testing during development </li> <li>\u2705 Export results to share with others</li> <li>\u2705 Maintain consistent configuration</li> </ul> <p>Continue learning:</p> <ul> <li>CLI Reference - All available options and advanced usage</li> <li>Configuration Reference - Complete configuration guide</li> </ul>"},{"location":"advanced/targeted/","title":"Targeted Property-Based Testing","text":"<p>Schemathesis supports targeted property-based testing to guide test data generation toward specific goals. This technique helps find problematic inputs faster by directing the test generator toward areas more likely to reveal issues.</p>"},{"location":"advanced/targeted/#maximizing-metrics","title":"Maximizing Metrics","text":"<p>The <code>--generation-maximize</code> option instructs Schemathesis to favor inputs that maximize a specific metric:</p> <pre><code>$ st run openapi.yaml --generation-maximize response_time\n</code></pre> <p>Currently supported metrics:</p> <ul> <li><code>response_time</code>: Favors inputs that result in longer API response times</li> </ul> <p>This approach is particularly useful for detecting:</p> <ul> <li>Performance bottlenecks</li> <li>Inputs that cause excessive processing</li> <li>Potential denial-of-service vulnerabilities</li> </ul> <p>Custom Metrics</p> <p>See Extending Metrics for details on implementing custom metrics for targeted testing.</p>"},{"location":"advanced/targeted/#example-scenario","title":"Example Scenario","text":"<p>Consider an API endpoint with a hidden performance issue where inputs containing many zeros cause progressively slower responses. At a certain threshold, the endpoint fails completely:</p> <pre><code>async def performance(request):\n    decoded = await request.json()\n    number = str(decoded).count(\"0\")\n    if number &gt; 0:\n        # Progressively slower as zeros increase\n        await asyncio.sleep(0.01 * number)\n    if number &gt; 10:\n        # Fails with too many zeros\n        raise ServerError()\n    return {\"result\": \"success\"}\n</code></pre> <p>When testing this endpoint:</p> <ul> <li>Standard testing might need many examples to stumble upon problematic inputs</li> <li>Targeted testing will progressively favor inputs with more zeros, finding the issue faster</li> </ul>"},{"location":"advanced/targeted/#performance-advantage","title":"Performance Advantage","text":"<p>In practice, targeted testing can significantly reduce the time needed to discover issues:</p> <pre><code># Standard testing might require many examples\n$ st run openapi.yaml --max-examples=10000\n\n# Targeted testing often finds issues with fewer examples\n$ st run openapi.yaml --max-examples=10000 --generation-maximize response_time\n</code></pre> <p>While results vary due to the random nature of property-based testing, targeted testing consistently improves efficiency on APIs with performance-related vulnerabilities.</p>"},{"location":"explanations/","title":"Core Concepts","text":""},{"location":"guides/","title":"Available Guides","text":""},{"location":"guides/cicd/","title":"Continuous Integration","text":"<p>This guide explains how to integrate Schemathesis into CI/CD pipelines for automated API testing. Automated tests catch API regressions early and help maintain consistent API quality across releases.</p>"},{"location":"guides/cicd/#general-integration-pattern","title":"General Integration Pattern","text":"<p>Schemathesis integration in CI follows this pattern:</p> <ol> <li>Start the API service.</li> <li>Wait for the API to become available.</li> <li>Run Schemathesis against the API schema.</li> <li>Process test results and generate reports.</li> </ol>"},{"location":"guides/cicd/#schema-access-strategies","title":"Schema Access Strategies","text":""},{"location":"guides/cicd/#url-based-schemas","title":"URL-Based Schemas","text":"<p>For APIs that expose their schema through an endpoint:</p> <pre><code>$ st run http://api-host:port/openapi.json\n</code></pre> <p>This approach ensures you're testing against the actual deployed schema but requires the API to be running.</p>"},{"location":"guides/cicd/#file-based-schemas","title":"File-Based Schemas","text":"<p>For APIs with separately maintained schemas, run tests against a local schema file. Ensure the schema file is kept in sync with the API.</p> <pre><code>$ st run ./path/to/openapi.json --url http://api-host:port\n</code></pre> <p>This approach lets you test against a local schema file by specifying the target URL, ensuring tests run against the intended API.</p>"},{"location":"guides/cicd/#using-configuration-files","title":"Using Configuration Files","text":"<p>For CI environments, create a dedicated configuration file (<code>schemathesis.toml</code>) with your testing settings. Schemathesis automatically loads this file from the current directory or project root.</p> <p>Since the config file supports environment variable substitution, you can use the same file across different environments by supplying different environment variables. To use a custom file, specify its path with <code>--config-file</code>.</p> <pre><code>[auth.openapi]\nApiKeyAuth = { value = \"${API_KEY}\" }\n\n[checks]\nresponse_schema_conformance.enabled = false\n\n[reports.junit]\npath = \"${JUNIT_REPORT_PATH}\"\n</code></pre> <p>Then in your CI workflow, simply reference this configuration:</p> <pre><code>$ st --config-file my-config.toml run http://api-host:port/openapi.json\n</code></pre> <p>Configuration Reference</p> <p>See the Configuration Guide for usage instructions and the Configuration Reference for all available options.</p>"},{"location":"guides/cicd/#exit-codes","title":"Exit Codes","text":"<p>Schemathesis returns these exit codes that you should handle in your CI job:</p> <ul> <li><code>0</code>: All tests passed</li> <li><code>1</code>: Tests failed</li> <li><code>2</code>: Invalid schema or configuration error</li> </ul>"},{"location":"guides/cicd/#platform-specific-integration","title":"Platform-Specific Integration","text":"<p>For detailed setup instructions on specific CI platforms:</p> <ul> <li>GitHub Actions</li> <li>GitLab CI</li> </ul> <p>Each platform guide includes concrete examples, authentication patterns, and troubleshooting advice specific to that environment.</p>"},{"location":"guides/extending/","title":"Extending Schemathesis","text":""},{"location":"guides/github-actions/","title":"Using Schemathesis with GitHub Actions","text":"<p>This tutorial demonstrates how to integrate Schemathesis with GitHub Actions for automated API testing. The implementation uses a demo Flask application with intentional errors to showcase Schemathesis's capabilities in a CI environment.</p>"},{"location":"guides/github-actions/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Docker and Python</li> <li>GitHub account</li> <li>Familiarity with GitHub Actions</li> </ul>"},{"location":"guides/github-actions/#setting-up-the-demo-environment","title":"Setting Up the Demo Environment","text":"<p>The demo repository contains a Flask application with several endpoints designed to trigger different types of API errors.</p> <pre><code>@app.route(\"/improper-unicode-encoding\", methods=[\"POST\"])\ndef improper_unicode_encoding():\n    data = request.json\n    if \"text\" not in data:\n        return jsonify({\"success\": False, \"error\": \"Missing text\"}), 400\n\n    try:\n        # Simulating improper Unicode handling\n        data[\"text\"].encode(\"ascii\")\n        return jsonify({\"success\": True})\n    except UnicodeEncodeError:\n        return jsonify({\"success\": False, \"error\": \"Unicode error\"}), 500\n</code></pre> <ol> <li> <p>Fork the demo repository to your GitHub account</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> <pre><code>$ git clone https://github.com/YOUR-USERNAME/schemathesis-demo.git\n$ cd schemathesis-demo\n</code></pre> <ol> <li>Start the application:</li> </ol> <pre><code>$ docker compose up -d\n</code></pre> <p>The API UI will be available at <code>http://127.0.0.1:5123/ui/</code></p>"},{"location":"guides/github-actions/#implementing-the-github-action","title":"Implementing the GitHub Action","text":"<p>The Schemathesis GitHub Action integrates API testing directly into your CI workflow.</p> <ol> <li>Create a new branch for the integration:</li> </ol> <pre><code>$ git checkout -b add-schemathesis-action\n</code></pre> <ol> <li>Create a workflow file at <code>.github/workflows/schemathesis.yml</code>:</li> </ol> <pre><code>name: Schemathesis Test\n\non: [pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Start containers\n      run: docker compose up -d --build\n\n    - uses: schemathesis/action@v1\n      with:\n        schema: 'http://127.0.0.1:5123/openapi.json'\n\n    - name: Stop containers\n      if: always()\n      run: docker-compose down\n</code></pre> <ol> <li>Commit and push your changes:</li> </ol> <pre><code>$ git add .github/workflows/schemathesis.yml\n$ git commit -m \"Add Schemathesis GitHub Action\"\n$ git push -u origin add-schemathesis-action\n</code></pre> <ol> <li>Open a pull request against your repository</li> </ol> <p>Note</p> <p>When opening the pull request, select your own repository as the base to ensure the workflow runs in your fork.</p> <p>The workflow will run when the PR is created, and Schemathesis will identify API issues:</p> <pre><code>________ POST /internal-server-errors/improper-unicode-encoding ________\n1. Test Case ID: F7IxDy\n\n- Server error\n\n[500] Internal Server Error:\n\n    `{\"error\":\"Unicode error\",\"success\":false}`\n\nReproduce with:\n\n    curl -X POST -H 'Content-Type: application/json' -d '{\"text\": \"\\u0080\"}' \n    http://127.0.0.1:5123/internal-server-errors/improper-unicode-encoding\n</code></pre>"},{"location":"guides/github-actions/#customizing-test-execution","title":"Customizing Test Execution","text":"<p>Customize the Schemathesis test run using action parameters:</p> <pre><code>- name: Set access token\n  run: echo \"TOKEN=super-secret\" &gt;&gt; $GITHUB_ENV\n\n- uses: schemathesis/action@v1\n  with:\n    schema: 'http://127.0.0.1:5123/openapi.json'\n    args: '-H \"Authorization: Bearer ${{ env.TOKEN }}\" --max-response-time=200'\n</code></pre> <p>This example adds an authorization header and sets a 200ms maximum response time threshold.</p> <p>For all available options, see the GitHub Action documentation.</p>"},{"location":"guides/gitlab-ci/","title":"GitLab CI Integration","text":"<p>This page shows how to run Schemathesis tests in GitLab CI/CD pipelines.</p>"},{"location":"guides/gitlab-ci/#basic-configuration","title":"Basic Configuration","text":"<p>Add this configuration to your <code>.gitlab-ci.yml</code> file:</p> <pre><code>api-tests:\n  stage: test\n  image:\n    name: schemathesis/schemathesis:stable\n    entrypoint: [\"\"]\n  script:\n    # Set up application here if needed\n    - st run http://127.0.0.1:5000/api/openapi.json\n</code></pre>"},{"location":"openapi/examples/","title":"Examples in API Schemas","text":"<p>Schema examples in OpenAPI are predefined sample values for request parameters and bodies. They serve as concrete test cases to validate that the API handles typical inputs correctly.</p> <p>Schemathesis supports these distinct testing paradigms:</p> <ul> <li>Example-based testing: Uses fixed input values from your schema to produce predictable, repeatable tests.</li> <li>Property-based testing: Generates a diverse range of inputs dynamically to expose unexpected edge cases.</li> </ul> <p>Use schema examples to verify critical business logic, ensure backward compatibility, and achieve deterministic test reproduction. In contrast, property-based testing is ideal for discovering unexpected edge cases and performance issues.</p>"},{"location":"openapi/examples/#defining-examples-in-openapi","title":"Defining Examples in OpenAPI","text":"<p>In OpenAPI 3.0+, use <code>example</code> for a single example and <code>examples</code> for multiple values. You can define examples at both the property and operation levels, or reference external files using <code>externalValue</code>.</p> <pre><code># Single example using the 'example' keyword\nschema:\n  type: object\n  properties:\n    name:\n      type: string\n      example: \"John Doe\"\n</code></pre> <pre><code># Multiple examples using the 'examples' keyword (OpenAPI 3.0+)\nschema:\n  type: object\n  properties:\n    name:\n      type: string\n      examples:\n        - \"John Doe\"\n        - \"Jane Smith\"\n</code></pre> <pre><code># Property-level example\nproperties:\n  name:\n    type: string\n    example: \"John Doe\"\n  age:\n    type: integer\n    example: 30\n</code></pre> <pre><code># Operation-level example\nrequestBody:\n  content:\n    application/json:\n      schema:\n        $ref: '#/components/schemas/User'\n      example:\n        name: \"John Doe\"\n        age: 30\n</code></pre> <pre><code>content:\n  application/json:\n    schema:\n      $ref: '#/components/schemas/User'\n    examples:\n      user:\n        summary: \"A typical user\"\n        externalValue: 'http://example.com/examples/user.json'\n</code></pre> <p>Schemathesis will load and cache external examples during testing.</p> <p>OpenAPI 2.0 Support</p> <p>In OpenAPI 2.0, use the <code>example</code> keyword or <code>x-examples</code> extension for multiple examples.</p> <pre><code># OpenAPI 2.0 with multiple examples\ndefinitions:\n  User:\n    type: object\n    properties:\n      name:\n        type: string\n    x-examples:\n      - name: \"John Doe\"\n      - name: \"Jane Smith\"\n</code></pre>"},{"location":"openapi/examples/#using-examples-in-tests","title":"Using Examples in Tests","text":"<p>Schemathesis automatically detects schema examples and uses them as test cases. For parameters without examples, it generates minimal valid values to ensure every operation is tested.</p> <pre><code># Schema\nschema:\n  type: object\n  properties:\n    name:\n      type: string\n      example: \"John\"\n    age:\n      type: integer\n    address:\n      type: string\n</code></pre> <p>This would generate test cases like:</p> <pre><code>{\"name\": \"John\", \"age\": 42, \"address\": \"abc\"}\n</code></pre> <p>Where <code>\"John\"</code> comes from the example, while the other values are minimal values that satisfy the schema constraints.</p>"},{"location":"openapi/examples/#command-line-interface","title":"Command-Line Interface","text":"<p>Run example-based tests only using the <code>--phases=examples</code> option:</p> <pre><code>$ st run --phases=examples https://example.schemathesis.io/openapi.json\n</code></pre> <p>This restricts testing to the examples phase, skipping other testing phases like coverage, fuzzing, and stateful testing.</p>"},{"location":"openapi/examples/#multiple-examples-strategy","title":"Multiple Examples Strategy","text":"<p>Schemathesis uses a round-robin strategy to evenly distribute test cases across multiple examples:</p> <pre><code># Schema\nproperties:\n  name:\n    type: string\n    example: \"John\"\n  age:\n    type: integer\n    examples: [25, 30, 35]\n</code></pre> <p>Schemathesis will generate test cases using each age value: <pre><code>{\"name\": \"John\", \"age\": 25, ...}\n{\"name\": \"John\", \"age\": 30, ...}\n{\"name\": \"John\", \"age\": 35, ...}\n</code></pre></p>"},{"location":"openapi/examples/#differences-with-dredd","title":"Differences with Dredd","text":"<p>Unlike Dredd, which depends exclusively on schema examples for generating test cases, Schemathesis employs a hybrid approach. It treats predefined examples as fixed test inputs while also dynamically generating additional inputs to explore the broader input space. This allows for both deterministic validation of documented scenarios and exploration of potential edge cases. Furthermore, Schemathesis supports test case reduction and stateful testing to isolate minimal failing inputs and validate complex operation sequences.</p> <p>Feedback</p> <p>If you rely on Dredd and find that a particular feature is missing in Schemathesis, please share your feedback via GitHub Discussions.</p>"},{"location":"reference/checks/","title":"Checks","text":""},{"location":"reference/cli/","title":"Schemathesis CLI Reference","text":"<p>This reference details all the command-line options available in the Schemathesis CLI. The documentation is organized by command and subcommand to provide a clear structure of available options and their usage.</p>"},{"location":"reference/cli/#global-options","title":"Global Options","text":"<p>These options apply to all Schemathesis commands:</p>"},{"location":"reference/cli/#-no-color","title":"<code>--no-color</code>","text":"<p>Disables ANSI color output in the terminal. Use this option when running in environments where color codes may cause issues or when redirecting output to files.</p>"},{"location":"reference/cli/#-force-color","title":"<code>--force-color</code>","text":"<p>Forces the use of ANSI color escape codes in terminal output, even in environments where Schemathesis would normally disable colors.</p>"},{"location":"reference/cli/#run","title":"<code>run</code>","text":"<p>The <code>run</code> command executes API tests against an API using a schema for test generation.</p> <pre><code>$ st run [OPTIONS] SCHEMA\n</code></pre> <p>Required Parameter</p> <p>SCHEMA: Path to an OpenAPI (<code>.json</code>, <code>.yml</code>) or GraphQL SDL file, or a URL pointing to such specifications. This schema defines the API surface to test.</p>"},{"location":"reference/cli/#basic-options","title":"Basic Options","text":""},{"location":"reference/cli/#-u-url-url","title":"<code>-u, --url URL</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies the base URL for the API under test. Required for file-based schemas.</p> <pre><code>$ st run openapi.yaml --url https://api.example.com\n</code></pre>"},{"location":"reference/cli/#-w-workers-value","title":"<code>-w, --workers VALUE</code>","text":"<p>Type: <code>Integer or \"auto\"</code> Default: <code>1</code> Range: <code>1-64</code> or <code>auto</code> </p> <p>Specifies the number of concurrent workers for running unit test phases (examples, coverage, fuzzing). Use \"auto\" to automatically adjust based on available CPU cores.</p> <pre><code>$ st run openapi.yaml --workers 4\n</code></pre>"},{"location":"reference/cli/#-phases-phases","title":"<code>--phases PHASES</code>","text":"<p>Type: <code>Comma-separated list</code> Default: All phases enabled Possible values: <code>examples</code>, <code>coverage</code>, <code>fuzzing</code>, <code>stateful</code> </p> <p>Specifies which test phases to run.</p> <pre><code>$ st run openapi.yaml --phases examples,fuzzing\n</code></pre>"},{"location":"reference/cli/#-suppress-health-check-checks","title":"<code>--suppress-health-check CHECKS</code>","text":"<p>Type: <code>Comma-separated list</code> Default: <code>[]</code> Possible values: <code>data_too_large</code>, <code>filter_too_much</code>, <code>too_slow</code>, <code>large_base_example</code>, <code>all</code> </p> <p>Disables specified health checks during test execution. Health checks identify potential problems with test generation or performance and may stop tests early with an error to prevent Schemathesis from hanging (e.g., when processing extremely complex schemas).</p> <pre><code>$ st run openapi.yaml --suppress-health-check too_slow,data_too_large\n</code></pre>"},{"location":"reference/cli/#-wait-for-schema-seconds","title":"<code>--wait-for-schema SECONDS</code>","text":"<p>Type: <code>Float</code> Default: <code>null</code> Range: <code>\u22651.0</code> </p> <p>Maximum time in seconds to wait for the API schema to become available. Useful when testing services that take time to start up.</p> <pre><code>$ st run https://api.example.com/openapi.json --wait-for-schema 5.0\n</code></pre>"},{"location":"reference/cli/#validation","title":"Validation","text":""},{"location":"reference/cli/#-c-checks-checks","title":"<code>-c, --checks CHECKS</code>","text":"<p>Type: <code>Comma-separated list</code> Default: All checks enabled Possible values: <code>not_a_server_error</code>, <code>status_code_conformance</code>, <code>content_type_conformance</code>, <code>response_headers_conformance</code>, <code>response_schema_conformance</code>, <code>negative_data_rejection</code>, <code>positive_data_acceptance</code>, <code>use_after_free</code>, <code>ensure_resource_availability</code>, <code>ignored_auth</code>, <code>all</code> </p> <p>Specifies which checks to run against API responses.</p> <pre><code>$ st run openapi.yaml --checks not_a_server_error,response_schema_conformance\n</code></pre>"},{"location":"reference/cli/#-exclude-checks-checks","title":"<code>--exclude-checks CHECKS</code>","text":"<p>Type: <code>Comma-separated list</code> Default: <code>[]</code> Possible values: <code>not_a_server_error</code>, <code>status_code_conformance</code>, <code>content_type_conformance</code>, <code>response_headers_conformance</code>, <code>response_schema_conformance</code>, <code>negative_data_rejection</code>, <code>positive_data_acceptance</code>, <code>use_after_free</code>, <code>ensure_resource_availability</code>, <code>ignored_auth</code>, <code>all</code> </p> <p>Specifies which checks to skip during testing.</p> <pre><code>$ st run openapi.yaml --checks all --exclude-checks response_schema_conformance\n</code></pre>"},{"location":"reference/cli/#-max-failures-count","title":"<code>--max-failures COUNT</code>","text":"<p>Type: <code>Integer</code> Default: <code>null</code> Range: <code>\u22651</code> </p> <p>Terminates the test suite after reaching a specified number of failures or errors.</p> <pre><code>$ st run openapi.yaml --max-failures 5\n</code></pre>"},{"location":"reference/cli/#-continue-on-failure","title":"<code>--continue-on-failure</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>When enabled, continues executing all test cases within a scenario, even after encountering failures.</p> <pre><code>$ st run openapi.yaml --continue-on-failure\n</code></pre>"},{"location":"reference/cli/#-max-response-time-seconds","title":"<code>--max-response-time SECONDS</code>","text":"<p>Type: <code>Float</code> Default: <code>null</code> Range: <code>&gt;0.0</code> </p> <p>Maximum allowed API response time in seconds. Responses exceeding this limit will be reported as failures.</p> <pre><code>$ st run openapi.yaml --max-response-time 2.5\n</code></pre>"},{"location":"reference/cli/#filtering","title":"Filtering","text":"<p>Schemathesis provides various ways to filter which operations are tested:</p>"},{"location":"reference/cli/#-include-type-value-exclude-type-value","title":"<code>--include-TYPE VALUE</code> / <code>--exclude-TYPE VALUE</code>","text":"<p>Type: <code>String</code> </p> <p>Include or exclude operations by exact match on path, method, tag, or operation-id.</p> <pre><code>$ st run openapi.yaml --include-tag users\n$ st run openapi.yaml --exclude-method DELETE\n</code></pre>"},{"location":"reference/cli/#-include-type-regex-pattern-exclude-type-regex-pattern","title":"<code>--include-TYPE-regex PATTERN</code> / <code>--exclude-TYPE-regex PATTERN</code>","text":"<p>Type: <code>String (regex pattern)</code> </p> <p>Include or exclude operations matching a regular expression pattern on path, method, tag, or operation-id.</p> <pre><code>$ st run openapi.yaml --include-path-regex \"/api/v1/.*\"\n$ st run openapi.yaml --exclude-tag-regex \"admin|internal\"\n</code></pre>"},{"location":"reference/cli/#-include-by-expr-exclude-by-expr","title":"<code>--include-by EXPR</code> / <code>--exclude-by EXPR</code>","text":"<p>Type: <code>String (expression)</code> </p> <p>Include or exclude operations using a custom expression. The expression must start with a JSON Pointer.</p> <pre><code>$ st run openapi.yaml --include-by \"/tags/0 == 'user'\"\n</code></pre>"},{"location":"reference/cli/#-exclude-deprecated","title":"<code>--exclude-deprecated</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Skip deprecated API operations.</p> <pre><code>$ st run openapi.yaml --exclude-deprecated\n</code></pre>"},{"location":"reference/cli/#network","title":"Network","text":"<p>The following options control how Schemathesis makes network requests to the API under test:</p>"},{"location":"reference/cli/#-h-header-namevalue","title":"<code>-H, --header NAME:VALUE</code>","text":"<p>Type: <code>String (multiple allowed)</code> </p> <p>Add custom HTTP headers to all API requests. This option can be specified multiple times.</p> <pre><code>$ st run openapi.yaml \\\n  --header \"X-API-Key: abcdef123456\" \\\n  --header \"Accept-Language: en-US\"\n</code></pre>"},{"location":"reference/cli/#-a-auth-userpass","title":"<code>-a, --auth USER:PASS</code>","text":"<p>Type: <code>String</code> </p> <p>Authenticate all API requests with basic authentication.</p> <pre><code>$ st run openapi.yaml --auth username:password\n</code></pre>"},{"location":"reference/cli/#-proxy-url","title":"<code>--proxy URL</code>","text":"<p>Type: <code>String</code> </p> <p>Set the proxy for all network requests.</p> <pre><code>$ st run openapi.yaml --proxy http://localhost:8080\n</code></pre>"},{"location":"reference/cli/#-tls-verify-text","title":"<code>--tls-verify TEXT</code>","text":"<p>Type: <code>String or Boolean</code> Default: <code>true</code> </p> <p>Path to CA bundle for TLS verification, or 'false' to disable TLS verification.</p> <pre><code>$ st run openapi.yaml --tls-verify false\n$ st run openapi.yaml --tls-verify /path/to/ca-bundle.pem\n</code></pre>"},{"location":"reference/cli/#-rate-limit-text","title":"<code>--rate-limit TEXT</code>","text":"<p>Type: <code>String</code> Format: <code>&lt;limit&gt;/&lt;duration&gt;</code> </p> <p>Specify a rate limit for test requests. Supports 's' (seconds), 'm' (minutes), and 'h' (hours) as duration units.</p> <pre><code>$ st run openapi.yaml --rate-limit 100/m\n$ st run openapi.yaml --rate-limit 5/s\n</code></pre>"},{"location":"reference/cli/#-request-timeout-seconds","title":"<code>--request-timeout SECONDS</code>","text":"<p>Type: <code>Float</code> Range: <code>&gt;0.0</code> </p> <p>Timeout limit, in seconds, for each network request during tests.</p> <pre><code>$ st run openapi.yaml --request-timeout 5.0\n</code></pre>"},{"location":"reference/cli/#-request-cert-path","title":"<code>--request-cert PATH</code>","text":"<p>Type: <code>String (file path)</code> </p> <p>File path of unencrypted client certificate for authentication. The certificate can be bundled with a private key (e.g., PEM) or used with a separate private key.</p> <pre><code>$ st run openapi.yaml --request-cert /path/to/client-cert.pem\n</code></pre>"},{"location":"reference/cli/#-request-cert-key-path","title":"<code>--request-cert-key PATH</code>","text":"<p>Type: <code>String (file path)</code> </p> <p>Specify the file path of the private key for the client certificate when not bundled together.</p> <pre><code>$ st run openapi.yaml \\\n  --request-cert /path/to/client-cert.crt \\\n  --request-cert-key /path/to/private-key.key\n</code></pre>"},{"location":"reference/cli/#output","title":"Output","text":"<p>These options control the reporting and output format of test results:</p>"},{"location":"reference/cli/#-report-format","title":"<code>--report FORMAT</code>","text":"<p>Type: <code>Comma-separated list</code> Possible values: <code>junit</code>, <code>vcr</code>, <code>har</code> </p> <p>Generate test reports in specified formats as a comma-separated list.</p> <pre><code>$ st run openapi.yaml --report junit,har\n</code></pre>"},{"location":"reference/cli/#-report-dir-directory","title":"<code>--report-dir DIRECTORY</code>","text":"<p>Type: <code>String</code> Default: <code>schemathesis-report</code> </p> <p>Directory to store all report files.</p> <pre><code>$ st run openapi.yaml --report junit --report-dir ./test-reports\n</code></pre>"},{"location":"reference/cli/#-report-junit-path-filename","title":"<code>--report-junit-path FILENAME</code>","text":"<p>Type: <code>String</code> </p> <p>Custom path for JUnit XML report.</p> <pre><code>$ st run openapi.yaml --report junit --report-junit-path ./custom-junit.xml\n</code></pre>"},{"location":"reference/cli/#-report-vcr-path-filename","title":"<code>--report-vcr-path FILENAME</code>","text":"<p>Type: <code>String</code> </p> <p>Custom path for VCR cassette.</p> <pre><code>$ st run openapi.yaml --report vcr --report-vcr-path ./custom-vcr.yaml\n</code></pre>"},{"location":"reference/cli/#-report-har-path-filename","title":"<code>--report-har-path FILENAME</code>","text":"<p>Type: <code>String</code> </p> <p>Custom path for HAR file.</p> <pre><code>$ st run openapi.yaml --report har --report-har-path ./custom-har.json\n</code></pre>"},{"location":"reference/cli/#-report-preserve-bytes","title":"<code>--report-preserve-bytes</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Retain exact byte sequence of payloads in cassettes, encoded as base64.</p> <pre><code>$ st run openapi.yaml --report vcr --report-preserve-bytes\n</code></pre>"},{"location":"reference/cli/#-output-sanitize-boolean","title":"<code>--output-sanitize BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Enable or disable automatic output sanitization to obscure sensitive data.</p> <pre><code>$ st run openapi.yaml --output-sanitize false\n</code></pre>"},{"location":"reference/cli/#-output-truncate-boolean","title":"<code>--output-truncate BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Truncate schemas and responses in error messages for improved readability.</p> <pre><code>$ st run openapi.yaml --output-truncate false\n</code></pre>"},{"location":"reference/cli/#data-generation","title":"Data Generation","text":"<p>These options control how Schemathesis generates test data for API testing:</p>"},{"location":"reference/cli/#-m-mode-mode","title":"<code>-m, --mode MODE</code>","text":"<p>Type: <code>String</code> Default: <code>positive</code> Possible values: <code>positive</code>, <code>negative</code>, <code>all</code> </p> <p>Test data generation mode. Controls whether Schemathesis generates valid data, invalid data, or both.</p> <pre><code>$ st run openapi.yaml --mode all\n</code></pre>"},{"location":"reference/cli/#-n-max-examples-count","title":"<code>-n, --max-examples COUNT</code>","text":"<p>Type: <code>Integer</code> Range: <code>\u22651</code> </p> <p>Maximum number of test cases per API operation.</p> <pre><code>$ st run openapi.yaml --max-examples 100\n</code></pre>"},{"location":"reference/cli/#-seed-integer","title":"<code>--seed INTEGER</code>","text":"<p>Type: <code>Integer</code> </p> <p>Random seed for reproducible test runs. Setting the same seed value will result in the same sequence of generated test cases.</p> <pre><code>$ st run openapi.yaml --seed 42\n</code></pre>"},{"location":"reference/cli/#-no-shrink","title":"<code>--no-shrink</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Disable test case shrinking. Makes test failures harder to debug but improves performance.</p> <pre><code>$ st run openapi.yaml --no-shrink\n</code></pre>"},{"location":"reference/cli/#-generation-deterministic","title":"<code>--generation-deterministic</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Enables deterministic mode, which eliminates random variation between tests.</p> <pre><code>$ st run openapi.yaml --generation-deterministic\n</code></pre>"},{"location":"reference/cli/#-generation-allow-x00-boolean","title":"<code>--generation-allow-x00 BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Whether to allow the generation of 'NULL' bytes within strings.</p> <pre><code>$ st run openapi.yaml --generation-allow-x00 false\n</code></pre>"},{"location":"reference/cli/#-generation-codec-text","title":"<code>--generation-codec TEXT</code>","text":"<p>Type: <code>String</code> </p> <p>The codec used for generating strings. Defines the character encoding for string generation.</p> <pre><code>$ st run openapi.yaml --generation-codec ascii\n</code></pre>"},{"location":"reference/cli/#-generation-maximize-metric","title":"<code>--generation-maximize METRIC</code>","text":"<p>Type: <code>String</code> Possible values: <code>response_time</code> </p> <p>Guide input generation to values more likely to expose bugs via targeted property-based testing.</p> <pre><code>$ st run openapi.yaml --generation-maximize response_time\n</code></pre>"},{"location":"reference/cli/#-generation-with-security-parameters-boolean","title":"<code>--generation-with-security-parameters BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Whether to generate security parameters during testing.</p> <pre><code>$ st run openapi.yaml --generation-with-security-parameters false\n</code></pre>"},{"location":"reference/cli/#-generation-graphql-allow-null-boolean","title":"<code>--generation-graphql-allow-null BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Whether to use <code>null</code> values for optional arguments in GraphQL queries. Applicable only for GraphQL API testing.</p> <pre><code>$ st run openapi.yaml --generation-graphql-allow-null false\n</code></pre>"},{"location":"reference/cli/#-generation-database-text","title":"<code>--generation-database TEXT</code>","text":"<p>Type: <code>String</code> Default: <code>.hypothesis/examples</code> </p> <p>Storage for examples discovered by Schemathesis. Use <code>none</code> to disable, <code>:memory:</code> for temporary storage, or specify a file path for persistent storage.</p> <pre><code>$ st run openapi.yaml --generation-database \":memory:\"\n$ st run openapi.yaml --generation-database ./schemathesis_examples.db\n</code></pre>"},{"location":"reference/cli/#-generation-unique-inputs","title":"<code>--generation-unique-inputs</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Force the generation of unique test cases. When enabled, Schemathesis will ensure that no duplicate test inputs are used within a single test phase.</p> <pre><code>$ st run openapi.yaml --generation-unique-inputs\n</code></pre>"},{"location":"reference/configuration/","title":"Configuration Options","text":"<p>This reference covers all the configuration options available in <code>schemathesis.toml</code>. The settings are organized into two main categories:</p> <ul> <li>Global: These control CLI behavior, output formatting, and overall test execution. They are defined at the top level and affect the CLI invocation.</li> <li>Per-Project: These let you customize configurations for individual API projects. If project-level settings are placed at the top level (without a <code>[[project]]</code> namespace), they are used as defaults for any tested project.</li> </ul>"},{"location":"reference/configuration/#configuration-resolution","title":"Configuration Resolution","text":"<p>Schemathesis applies settings in the following hierarchy (from highest to lowest precedence):</p> <ol> <li>CLI options</li> <li>Operation-specific phase settings</li> <li>Global phase settings (e.g., <code>[phases.fuzzing]</code>)</li> <li>Operation-level settings (e.g., <code>[[operations]]</code>)</li> <li>Project-level settings (e.g., <code>[[project]]</code>)</li> <li>Global settings</li> </ol>"},{"location":"reference/configuration/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>Schemathesis supports using environment variables in configuration files with the <code>${VAR_NAME}</code> syntax:</p> <pre><code>base-url = \"https://${API_HOST}/v1\"\nheaders = { Authorization = \"Bearer ${API_TOKEN}\" }\n</code></pre> <p>This allows you to maintain a single configuration file across different environments by changing environment variables rather than the configuration itself.</p>"},{"location":"reference/configuration/#operation-specific-configuration","title":"Operation-Specific Configuration","text":"<p>Schemathesis allows applying custom configuration to specific API operations in a few ways:</p> <pre><code>[[operations]]\n# By exact path\ninclude-path = \"/users\"\n# By HTTP method\nexclude-method = \"POST\"\n# By full operation name\n# include-name = \"POST /users/\"\n# By Open API tag\n# include-tag = \"admin\"\n# By Open API operation ID\n# include-operation-id = \"delete-user\"\n</code></pre>"},{"location":"reference/configuration/#parameter-overrides","title":"Parameter Overrides","text":"<p>Parameters can be overridden at the global or operation level:</p> <pre><code># Global parameters\n[parameters]\napi_version = \"v2\"\n\n# Operation-specific parameters\n[[operations]]\ninclude-name = \"GET /users/\"\nparameters = { limit = 50, offset = 0 }\n\n[[operations]]\ninclude-name = \"GET /users/{user_id}/\"\n# Disambiguate parameters with the same name\nparameters = { \"path.user_id\" = 42, \"query.user_id\" = 100 }\n</code></pre>"},{"location":"reference/configuration/#global-settings","title":"Global Settings","text":""},{"location":"reference/configuration/#color","title":"<code>color</code>","text":"<p>Type: <code>Boolean or None</code> Default: <code>null</code> </p> <p>Controls ANSI color output in the CLI. Schemathesis auto-detects color support by default. Set to <code>true</code> to force color output or <code>false</code> to disable it.</p> <pre><code>color = false\n</code></pre>"},{"location":"reference/configuration/#suppress-health-check","title":"<code>suppress-health-check</code>","text":"<p>Type: <code>Array[String]</code> Default: <code>[]</code> </p> <p>Specifies a list of health checks to disable during test execution. Possible values include: <code>data_too_large</code>, <code>filter_too_much</code>, <code>too_slow</code>, <code>large_base_example</code>, and <code>all</code>.</p> <pre><code>suppress-health-check = [\"too_slow\", \"data_too_large\"]\n</code></pre>"},{"location":"reference/configuration/#seed","title":"<code>seed</code>","text":"<p>Type: <code>Integer</code> Default: <code>null</code> </p> <p>Random seed for reproducible test runs. Setting the same seed value will result in the same sequence of generated test cases.</p> <pre><code>seed = 42\n</code></pre>"},{"location":"reference/configuration/#max-failures","title":"<code>max-failures</code>","text":"<p>Type: <code>Integer (\u22651)</code> Default: <code>null</code> </p> <p>Terminates the test run after the specified number of failures is reached.</p> <pre><code>max-failures = 42\n</code></pre>"},{"location":"reference/configuration/#reporting","title":"Reporting","text":""},{"location":"reference/configuration/#reportsdirectory","title":"<code>reports.directory</code>","text":"<p>Type: <code>String</code> Default: <code>\"schemathesis-report\"</code> </p> <p>Specifies the directory where all test reports are stored.</p> <pre><code>[reports]\ndirectory = \"test-results\"\n</code></pre>"},{"location":"reference/configuration/#reportspreserve-bytes","title":"<code>reports.preserve-bytes</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Retains the exact byte sequences of payloads in reports, encoded as base64 when enabled.</p> <pre><code>[reports]\npreserve-bytes = true\n</code></pre>"},{"location":"reference/configuration/#reportsformatenabled","title":"<code>reports.&lt;format&gt;.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Enables the generation of the specified report format. Replace <code>&lt;format&gt;</code> with one of: <code>junit</code>, <code>vcr</code>, or <code>har</code>.</p> <pre><code>[reports.junit]\nenabled = true\n</code></pre>"},{"location":"reference/configuration/#reportsformatpath","title":"<code>reports.&lt;format&gt;.path</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies a custom path for the report of the specified format. Replace <code>&lt;format&gt;</code> with one of: <code>junit</code>, <code>vcr</code>, or <code>har</code>.</p> <p>Setting this option automatically enables the report generation without requiring <code>enable = true</code>.</p> <pre><code>[reports.junit]\npath = \"./test-reports/schemathesis-results.xml\"\n</code></pre>"},{"location":"reference/configuration/#output","title":"Output","text":""},{"location":"reference/configuration/#outputsanitizationenabled","title":"<code>output.sanitization.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls automatic sanitization of output data to obscure sensitive information.</p> <pre><code>[output.sanitization]\nenabled = false\n</code></pre>"},{"location":"reference/configuration/#outputsanitizationkeys-to-sanitize","title":"<code>output.sanitization.keys-to-sanitize</code>","text":"<p>Type: <code>List[String]</code> Default: List of common sensitive keys (auth tokens, passwords, etc.)  </p> <p>Specific keys that will be automatically sanitized in output data.</p> <pre><code>[output.sanitization]\nkeys-to-sanitize = [\"password\", \"token\", \"auth\"]\n</code></pre>"},{"location":"reference/configuration/#outputsanitizationsensitive-markers","title":"<code>output.sanitization.sensitive-markers</code>","text":"<p>Type: <code>List[String]</code> Default: <code>[\"token\", \"key\", \"secret\", \"password\", \"auth\", \"session\", \"passwd\", \"credential\"]</code> </p> <p>Substrings that indicate a key might contain sensitive information requiring sanitization.</p> <pre><code>[output.sanitization]\nsensitive-markers = [\"secret\", \"auth\", \"key\"]\n</code></pre>"},{"location":"reference/configuration/#outputsanitizationreplacement","title":"<code>output.sanitization.replacement</code>","text":"<p>Type: <code>String</code> Default: <code>\"[Filtered]\"</code> </p> <p>The text used to replace sensitive data in output.</p> <pre><code>[output.sanitization]\nreplacement = \"***REDACTED***\"\n</code></pre>"},{"location":"reference/configuration/#outputtruncationenabled","title":"<code>output.truncation.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether large output data should be truncated.</p> <pre><code>[output.truncation]\nenabled = false\n</code></pre>"},{"location":"reference/configuration/#outputtruncationmax-payload-size","title":"<code>output.truncation.max-payload-size</code>","text":"<p>Type: <code>Integer</code> Default: <code>512</code> </p> <p>Maximum size in bytes for payloads before truncation occurs.</p> <pre><code>[output.truncation]\nmax-payload-size = 1024\n</code></pre>"},{"location":"reference/configuration/#outputtruncationmax-lines","title":"<code>output.truncation.max-lines</code>","text":"<p>Type: <code>Integer</code> Default: <code>10</code> </p> <p>Maximum number of lines to display for multi-line output.</p> <pre><code>[output.truncation]\nmax-lines = 20\n</code></pre>"},{"location":"reference/configuration/#outputtruncationmax-width","title":"<code>output.truncation.max-width</code>","text":"<p>Type: <code>Integer</code> Default: <code>80</code> </p> <p>Maximum width in characters for each line before horizontal truncation.</p> <pre><code>[output.truncation]\nmax-width = 100\n</code></pre>"},{"location":"reference/configuration/#project-settings","title":"Project Settings","text":"<p>These settings can only be applied at the project level.</p>"},{"location":"reference/configuration/#base-url","title":"<code>base-url</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Sets the base URL for the API under test. This setting is required when testing with a file-based schema.</p> <pre><code># Optionally under a named project\n# [[project]]\nbase-url = \"https://api.example.com\"\n</code></pre>"},{"location":"reference/configuration/#hooks","title":"<code>hooks</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies a Python module path where custom hooks for extending Schemathesis functionality are located. This allows you to define custom checks, adjust data generation, or extend CLI.</p> <pre><code># Global hooks for all projects\nhooks = \"myproject.tests.hooks\"\n\n# Or project-specific hooks\n# [[project]]\n# hooks = \"myproject.payments.hooks\"\n</code></pre>"},{"location":"reference/configuration/#workers","title":"<code>workers</code>","text":"<p>Type: <code>Integer or \"auto\"</code> Default: <code>1</code> </p> <p>Specifies the number of concurrent workers for running unit test phases.</p> <pre><code>workers = 4       # Use exactly 4 workers\n</code></pre>"},{"location":"reference/configuration/#wait-for-schema","title":"<code>wait-for-schema</code>","text":"<p>Type: <code>Number (\u22651.0)</code> Default: <code>null</code> </p> <p>Maximum duration, in seconds, to wait for the API schema to become available. Useful when testing services that take time to start up.</p> <pre><code>wait-for-schema = 5.0\n</code></pre>"},{"location":"reference/configuration/#continue-on-failure","title":"<code>continue-on-failure</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>When enabled, continues executing all test cases within a scenario, even after encountering failures.</p> <pre><code>continue-on-failure = true\n</code></pre>"},{"location":"reference/configuration/#phases","title":"Phases","text":""},{"location":"reference/configuration/#phasesphaseenabled","title":"<code>phases.&lt;phase&gt;.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Enables a testing phase. Replace <code>&lt;phase&gt;</code> with one of: <code>examples</code>, <code>coverage</code>, <code>fuzzing</code>, or <code>stateful</code>.</p> <pre><code>[phases.coverage]\nenabled = false\n</code></pre>"},{"location":"reference/configuration/#phasescoverageunexpected-methods","title":"<code>phases.coverage.unexpected-methods</code>","text":"<p>Type: <code>Array[String]</code> Default: <code>[]</code> </p> <p>Lists the HTTP methods to use when generating test cases with methods not specified in the API during the coverage phase. Schemathesis will limit negative testing of unexpected methods to those in the array; if omitted, all HTTP methods not specified in the spec are applied.</p> <pre><code>[phases.coverage]\nunexpected-methods = [\"PATCH\"]\n</code></pre>"},{"location":"reference/configuration/#phasesstatefulmax-steps","title":"<code>phases.stateful.max-steps</code>","text":"<p>Type: <code>Integer (\u22652)</code> Default: <code>null</code> </p> <p>Specifies the maximum number of stateful steps (i.e., transitions between states) to perform in the stateful phase. When set, Schemathesis will stop exploring new state transitions once this limit is reached, even if additional valid transitions are available.  </p> <pre><code>[phases.stateful]\nmax-steps = 50\n</code></pre>"},{"location":"reference/configuration/#phasesphasechecks","title":"<code>phases.&lt;phase&gt;.checks</code>","text":"<p>Type: <code>Object</code> Default: <code>{}</code> </p> <p>Phase-specific overrides for checks.</p> <pre><code>[phases.coverage.checks]\nnot_a_server_error.enabled = false\n</code></pre>"},{"location":"reference/configuration/#authentication","title":"Authentication","text":""},{"location":"reference/configuration/#authbasic","title":"<code>auth.basic</code>","text":"<p>Type: <code>Object</code> Default: <code>null</code> </p> <p>Provides basic authentication credentials. Define this object with <code>username</code> and <code>password</code> keys. This setting corresponds to the <code>--auth</code> CLI option.</p> <pre><code>[auth]\nbasic = { username = \"${USERNAME}\", password = \"${PASSWORD}\" }\n</code></pre>"},{"location":"reference/configuration/#checks","title":"Checks","text":""},{"location":"reference/configuration/#checkscheckenabled","title":"<code>checks.&lt;check&gt;.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Enables or disables the specified check. Replace <code>&lt;check&gt;</code> with one of the following:</p> <ul> <li><code>not_a_server_error</code></li> <li><code>status_code_conformance</code></li> <li><code>content_type_conformance</code></li> <li><code>response_schema_conformance</code></li> <li><code>positive_data_acceptance</code></li> <li><code>negative_data_rejection</code></li> <li><code>use_after_free</code></li> <li><code>ensure_resource_availability</code></li> <li><code>missing_required_header</code></li> <li><code>ignored_auth</code></li> <li><code>unsupported_method</code></li> </ul> <pre><code>[checks]\nresponse_schema_conformance.enabled = false\n</code></pre>"},{"location":"reference/configuration/#checkscheckexpected-statuses","title":"<code>checks.&lt;check&gt;.expected-statuses</code>","text":"<p>Type: <code>Array[Integer | String]</code> Default: <code>[200]</code> </p> <p>Defines the HTTP status codes expected from the API for specific checks. Different checks may interpret this setting differently:</p> <ul> <li>For <code>positive_data_acceptance</code>: Defines status codes that indicate the API has accepted valid data</li> <li>For <code>negative_data_rejection</code>: Defines status codes that indicate the API has properly rejected invalid data</li> <li>For <code>missing_required_header</code>: Defines status codes that indicate the API has properly rejected a call without required header</li> <li>For <code>not_a_server_error</code>: Defines status codes that are not considered server errors within the 5xx range</li> </ul> <p>This allows you to customize validation for APIs that use non-standard success or error codes.</p> <p>Status codes can be specified as exact integers (e.g., <code>200</code>) or as wildcard strings using the <code>X</code> character to match any digit (e.g., <code>\"2XX\"</code> to match all 2xx codes, <code>\"4XX\"</code> for all client error responses).</p> <pre><code>[checks]\npositive_data_acceptance.expected-statuses = [200, 201, 202]\n</code></pre>"},{"location":"reference/configuration/#checksmax_response_time","title":"<code>checks.max_response_time</code>","text":"<p>Type: <code>Float (&gt;0)</code> Default: <code>null</code> </p> <p>Maximum allowed API response time in seconds. Responses exceeding this limit will be reported as failures.</p> <pre><code>[checks]\nmax_response_time = 2.0\n</code></pre>"},{"location":"reference/configuration/#network","title":"Network","text":"<p>The following settings control how Schemathesis makes network requests to the API under test.</p>"},{"location":"reference/configuration/#header","title":"<code>header</code>","text":"<p>Type: <code>Object</code> Default: <code>{}</code> </p> <p>Add custom HTTP headers to all API requests. Headers are specified as key-value pairs.</p> <p>Add a single header:</p> <pre><code>headers = { \"X-API-Key\" = \"${API_KEY}\" }\n</code></pre> <p>Add multiple headers:</p> <pre><code>headers = { \"X-API-Key\" = \"${API_KEY}\", \"Accept-Language\" = \"en-US\" }\n</code></pre>"},{"location":"reference/configuration/#proxy","title":"<code>proxy</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Set the proxy URL for all network requests. Supports HTTP and HTTPS proxies.</p> <p>HTTP proxy:</p> <pre><code>proxy = \"http://localhost:8080\"\n</code></pre> <p>HTTPS proxy with authentication:</p> <pre><code>proxy = \"https://${USERNAME}:${PASSWORD}@proxy.example.com:8443\"\n</code></pre>"},{"location":"reference/configuration/#tls-verify","title":"<code>tls-verify</code>","text":"<p>Type: <code>String | Boolean</code> Default: <code>true</code> </p> <p>Control TLS certificate verification. Can be a boolean or a path to a CA bundle file.</p> <p>Disable TLS verification:</p> <pre><code>tls-verify = false\n</code></pre> <p>Use a custom CA bundle:</p> <pre><code>tls-verify = \"/path/to/ca-bundle.pem\"\n</code></pre>"},{"location":"reference/configuration/#rate-limit","title":"<code>rate-limit</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specify a rate limit for test requests in '/' format. Supports 's' (seconds), 'm' (minutes), and 'h' (hours) as duration units. <p>100 requests per minute:</p> <pre><code>rate-limit = \"100/m\"\n</code></pre> <p>5 requests per second:</p> <pre><code>rate-limit = \"5/s\"\n</code></pre> <p>1000 requests per hour:</p> <pre><code>rate-limit = \"1000/h\"\n</code></pre>"},{"location":"reference/configuration/#request-timeout","title":"<code>request-timeout</code>","text":"<p>Type: <code>Float</code> Default: <code>null</code> </p> <p>Set a timeout limit in seconds for each network request during tests. Must be a positive number.</p> <p>5 second timeout:</p> <pre><code>request-timeout = 5.0\n</code></pre> <p>500 millisecond timeout:</p> <pre><code>request-timeout = 0.5\n</code></pre>"},{"location":"reference/configuration/#request-cert","title":"<code>request-cert</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>File path to an unencrypted client certificate for authentication. The certificate can be bundled with a private key (e.g., PEM) or used with a separate private key specified by <code>request-cert-key</code>.</p> <pre><code># Client certificate with bundled private key\nrequest-cert = \"/path/to/client-cert.pem\"\n</code></pre>"},{"location":"reference/configuration/#request-cert-key","title":"<code>request-cert-key</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>File path to the private key for the client certificate when not bundled together.</p> <pre><code># Set certificate and separate private key\nrequest-cert = \"/path/to/client-cert.crt\"\nrequest-cert-key = \"/path/to/private-key.key\"\n</code></pre>"},{"location":"reference/configuration/#data-generation","title":"Data Generation","text":"<p>The following settings control how Schemathesis generates test data for your API testing.</p>"},{"location":"reference/configuration/#generationmode","title":"<code>generation.mode</code>","text":"<p>Type: <code>String</code> Default: <code>\"all\"</code> </p> <p>Test data generation mode. Controls whether Schemathesis generates valid data, invalid data, or both.</p> <p>Possible values:</p> <ul> <li><code>\"positive\"</code>: Generate only valid data according to the schema</li> <li><code>\"negative\"</code>: Generate only invalid data to test error handling</li> <li><code>\"all\"</code>: Generate both valid and invalid data</li> </ul> <pre><code>[generation]\nmode = \"negative\"\n</code></pre>"},{"location":"reference/configuration/#generationmax-examples","title":"<code>generation.max-examples</code>","text":"<p>Type: <code>Integer</code> Default: <code>100</code> </p> <p>Maximum number of test cases generated per API operation. Must be greater than or equal to 1.</p> <p>This setting has different effects depending on the test phase:</p> <ul> <li>In fuzzing phase: Controls the maximum number of examples generated per API operation</li> <li>In stateful phase: Determines the maximum number of distinct API call sequences</li> <li>In examples and coverage phases: Has no effect, as these use predetermined test cases</li> </ul> <pre><code>[generation]\nmax-examples = 200\n</code></pre>"},{"location":"reference/configuration/#generationno-shrink","title":"<code>generation.no-shrink</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Disable test case shrinking. When enabled, Schemathesis won't attempt to simplify failing test cases. This improves performance but makes test failures harder to debug.</p> <pre><code>[generation]\nno-shrink = true\n</code></pre>"},{"location":"reference/configuration/#generationdeterministic","title":"<code>generation.deterministic</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Enables deterministic mode, which eliminates random variation between tests. Useful for consistency in test outcomes.</p> <pre><code>[generation]\ndeterministic = true\n</code></pre>"},{"location":"reference/configuration/#generationallow-x00","title":"<code>generation.allow-x00</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether to allow the generation of 'NULL' bytes (0x00) within strings. Some systems may not handle these bytes correctly.</p> <pre><code>[generation]\nallow-x00 = false\n</code></pre>"},{"location":"reference/configuration/#generationexclude-header-characters","title":"<code>generation.exclude-header-characters</code>","text":"<p>Type: <code>String</code> Default: <code>\\r\\n</code> </p> <p>All characters from the given strings will be excluded from generated header values.</p> <pre><code>[generation]\nexclude-header-characters = \"\\r\\nABC\"\n</code></pre>"},{"location":"reference/configuration/#generationcodec","title":"<code>generation.codec</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>The codec used for generating strings. Defines the character encoding for string generation.</p> <pre><code>[generation]\ncodec = \"ascii\"\n</code></pre>"},{"location":"reference/configuration/#generationmaximize","title":"<code>generation.maximize</code>","text":"<p>Type: <code>String</code> or <code>Array[String]</code> Default: <code>null</code> </p> <p>Guide input generation to values more likely to expose bugs via targeted property-based testing.</p> <p>Possible values: - <code>\"response_time\"</code>: Focus on generating inputs that maximize response time</p> <pre><code>[generation]\nmaximize = \"response_time\"\n</code></pre>"},{"location":"reference/configuration/#generationwith-security-parameters","title":"<code>generation.with-security-parameters</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether to generate security parameters during testing. When enabled, Schemathesis will include appropriate security-related parameters in test data based on the API's security schemes defined in the schema.</p> <pre><code>[generation]\nwith-security-parameters = false\n</code></pre>"},{"location":"reference/configuration/#generationgraphql-allow-null","title":"<code>generation.graphql-allow-null</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether to use <code>\\x00</code> bytes in generated GraphQL queries. Applicable only for GraphQL API testing.</p> <pre><code>[generation]\ngraphql-allow-null = false\n</code></pre>"},{"location":"reference/configuration/#generationdatabase","title":"<code>generation.database</code>","text":"<p>Type: <code>String</code> Default: <code>.hypothesis/examples</code> </p> <p>Storage for examples discovered by Schemathesis. Options: - <code>\"none\"</code>: Disable storage - <code>\":memory:\"</code>: Use temporary in-memory storage - File path: For persistent storage in a custom location</p> <p>By default, Schemathesis creates a directory-based example database in your current working directory under <code>.hypothesis/examples</code>. If this location is unusable, Schemathesis will emit a warning and use an alternative.</p> <pre><code>[generation]\ndatabase = \":memory:\"\n</code></pre> <p>Or for persistent storage:</p> <pre><code>[generation]\ndatabase = \"./.schemathesis/examples/\"\n</code></pre>"},{"location":"reference/configuration/#generationunique-inputs","title":"<code>generation.unique-inputs</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Force the generation of unique test cases. When enabled, Schemathesis will ensure that no duplicate test inputs are used within a single test phase.</p> <pre><code>[generation]\nunique-inputs = true\n</code></pre>"},{"location":"reference/python/","title":"Python API Reference","text":""},{"location":"reference/reporting/","title":"Reporting Test Results","text":""},{"location":"using/configuration/","title":"Configuration","text":"<p>Schemathesis can be configured through a <code>schemathesis.toml</code> file.</p>"},{"location":"using/configuration/#configuration-file-location","title":"Configuration File Location","text":"<p>Schemathesis will look for configuration in the following locations, in order:</p> <ol> <li>Path specified via <code>--config-file</code> CLI option.</li> <li><code>schemathesis.toml</code> in the current directory.</li> <li><code>schemathesis.toml</code> in parent directories (up to the project root).</li> </ol> <p>Configuration Preference</p> <p>Schemathesis uses only one configuration file and does not merge settings from multiple files. If no <code>schemathesis.toml</code> file is found, Schemathesis will use its built-in defaults.</p>"},{"location":"using/configuration/#why-use-a-configuration-file","title":"Why Use a Configuration File?","text":"<p>While Schemathesis works well without explicit configuration, using a file offers several benefits:</p> <ul> <li>Operation-Specific Settings: Configure different behaviors for specific API operations. For example, run more tests or apply different validation rules</li> <li>Validation Customization: Adjust how API responses are validated. For example, disable not relevant checks on certain API operations.</li> <li>Consistent Testing: Share configuration across different environments and test runs.</li> </ul> <p>CLI and Python API Integration</p> <p>While the configuration file sets default behavior, CLI options and the Python API can override any settings.</p> <p>For a complete list of settings, see the Configuration Reference.</p>"},{"location":"using/configuration/#basic-structure","title":"Basic Structure","text":"<p>Schemathesis configuration uses the TOML format with a hierarchical structure. Global settings serve as defaults and can be overridden by more specific ones such as operation-specific or project-specific ones.</p> <pre><code># Global settings\nbase-url = \"https://api.example.com\"\ngeneration.max-examples = 100\n\n# Operation-specific settings\n[[operations]]\ninclude-name = \"GET /users\"\ngeneration.max-examples = 200\nrequest-timeout = 5.0\n</code></pre>"},{"location":"using/configuration/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>Schemathesis supports using environment variables in configuration files with the <code>${VAR_NAME}</code> syntax:</p> <pre><code># Use environment variables for sensitive or environment-specific values\nbase-url = \"https://${API_HOST}/v1\"\nheaders = { Authorization = \"Bearer ${API_TOKEN}\" }\n\n[[operations]]\ninclude-name = \"POST /payments\"\nheaders = { \"X-API-Key\" = \"${API_KEY}\" }\n</code></pre> <p>This allows you to maintain a single configuration file that works across different testing environments by changing environment variables rather than the configuration itself.</p> <p>Multi-Project Support</p> <p>Schemathesis also supports multi-project configurations, where you can define separate settings for different APIs within the same configuration file. See Multi-Project Configuration for details.</p> <p>Most users won't need a configuration file at all. Configuration becomes valuable primarily for complex testing scenarios.</p>"},{"location":"using/configuration/#authentication","title":"Authentication","text":"<p>For simple authentication, use the global <code>[auth]</code> section:</p> <pre><code>[auth]\n# Basic authentication\nbasic = { username = \"${USERNAME}\", password = \"${PASSWORD}\" }\n</code></pre> <p>The <code>basic</code> setting corresponds to the <code>--auth</code> CLI option.</p> <p>Operation-specific Authentication</p> <p>You can also override auth on the per-operation basis.</p>"},{"location":"using/configuration/#authentication-resolution","title":"Authentication Resolution","text":"<p>When multiple methods are specified, Schemathesis resolves authentication in the following order:</p> <ul> <li>CLI options (<code>--auth</code> or <code>--header</code>)</li> <li>Operation-specific headers</li> <li>Generic authentication (global <code>[auth]</code>)</li> </ul> <p>This flexible resolution lets you override settings at different levels while keeping sensitive data in environment variables.</p>"},{"location":"using/configuration/#test-phases","title":"Test Phases","text":"<p>Schemathesis runs tests in distinct phases, each with different approaches to generating and executing test cases.</p>"},{"location":"using/configuration/#available-phases","title":"Available Phases","text":"<p>Schemathesis includes the following test phases:</p> <ul> <li>examples: Tests using examples explicitly defined in your API schema</li> <li>coverage: Tests using deterministic edge cases and boundary values</li> <li>fuzzing: Tests using randomly generated values</li> <li>stateful: Tests API operation sequences to find state-dependent issues</li> </ul> <p>All phases are enabled by default.</p>"},{"location":"using/configuration/#phase-configuration","title":"Phase Configuration","text":"<p>Customize test phases using the <code>[phases]</code> section in your configuration file. For example:</p> <pre><code>[phases]\n# Disable a specific phase\ncoverage.enabled = false\n\n# Phase-specific settings\n# Maximum number of distinct API call sequences\nstateful.generation.max-examples = 30\n# Maximum examples per operation in fuzzing phase\nfuzzing.generation.max-examples = 200\n</code></pre>"},{"location":"using/configuration/#phase-specific-behavior","title":"Phase-Specific Behavior","text":"<p>Certain settings are interpreted differently across test phases. For instance, the <code>generation.max-examples</code> setting works as follows:</p> <ul> <li>fuzzing: Controls the maximum number of examples generated per API operation.</li> <li>stateful: Determines the maximum number of distinct API call sequences.</li> </ul> <p>Phases that use predetermined test cases (such as the examples and coverage phases) are unaffected by the <code>generation.max-examples</code> setting.</p> <p>Consider this example, which sets a global default while overriding it for the stateful phase:</p> <pre><code># Global setting\ngeneration.max-examples = 200\n\n[phases]\n# Override for stateful phase\nstateful.generation.max-examples = 30\n</code></pre>"},{"location":"using/configuration/#checks","title":"Checks","text":"<p>Schemathesis validates API responses with a series of checks that verify various aspects of your API's behavior\u2014from server availability to schema conformance.</p>"},{"location":"using/configuration/#available-checks","title":"Available Checks","text":"<p>Schemathesis includes the following checks (all enabled by default):</p> <ul> <li>not_a_server_error: API doesn't return 5xx responses.</li> <li>status_code_conformance: Status code is defined in the schema.</li> <li>content_type_conformance: Response content type is defined in the schema.</li> <li>response_schema_conformance: Response body conforms to its schema.</li> <li>positive_data_acceptance: Valid data is accepted.</li> <li>negative_data_rejection: Invalid data is rejected.</li> <li>use_after_free: Resource is inaccessible after deletion.</li> <li>ensure_resource_availability: Resource is available after creation.</li> <li>ignored_auth: Authentication is properly enforced.</li> </ul>"},{"location":"using/configuration/#global-check-configuration","title":"Global Check Configuration","text":"<p>Configure checks globally using the <code>[checks]</code> section:</p> <pre><code>[checks]\n# Disable checks globally\ncontent_type_conformance.enabled = false\n\n# Set check parameters\npositive_data_acceptance.expected-statuses = [200, 201, 202]\nnegative_data_rejection.expected-statuses = [400, 422]\n</code></pre>"},{"location":"using/configuration/#operation-specific-check-configuration","title":"Operation-Specific Check Configuration","text":"<p>Override check settings for a specific operation:</p> <pre><code>[[operations]]\ninclude-name = \"POST /users\"\n# Operation-specific check settings\nchecks.positive_data_acceptance.expected-statuses = [201]\nchecks.response_schema_conformance.enabled = false\n</code></pre>"},{"location":"using/configuration/#disabling-all-checks-except-selected-ones","title":"Disabling All Checks Except Selected Ones","text":"<p>To run only specific checks, disable all by default and then enable chosen ones:</p> <pre><code>[checks]\nenabled = false\n\n# Enable only selected checks\nnot_a_server_error.enabled = true\nstatus_code_conformance.enabled = true\n</code></pre> <p>This configuration runs only the server error and status code checks.</p>"},{"location":"using/configuration/#check-resolution","title":"Check Resolution","text":"<p>Schemathesis applies check configurations in the following order:</p> <ul> <li>Operation</li> <li>Phase</li> <li>Global</li> </ul> <p>This hierarchy lets you define global defaults while overriding settings for specific endpoints.</p>"},{"location":"using/configuration/#operation-specific-configuration","title":"Operation-Specific Configuration","text":"<p>Schemathesis allows you to apply custom configuration to specific API operations. You can include or exclude operations based on various criteria.</p>"},{"location":"using/configuration/#basic-configuration-structure","title":"Basic Configuration Structure","text":"<p>Use arrays of tables with inclusion and exclusion filters:</p> <pre><code>[[operations]]\ninclude-path = \"/users\"\ngeneration.max-examples = 200\nrequest-timeout = 5.0\n\n[[operations]]\ninclude-tag = \"admin\"\nenabled = false\n</code></pre>"},{"location":"using/configuration/#multiple-values-for-filters","title":"Multiple Values for Filters","text":"<p>For any filter type, you can provide an array of strings to match against multiple values. This works as an OR condition - if any value in the array matches, the filter applies:</p> <pre><code>[[operations]]\ninclude-path = [\"/users\", \"/accounts\", \"/profiles\"]\ngeneration.max-examples = 150\n\n[[operations]]\ninclude-tag = [\"admin\", \"management\"]\nrequest-timeout = 3.0\n</code></pre> <p>This feature works with all filter types, except regex and custom expressions.</p>"},{"location":"using/configuration/#filter-types","title":"Filter Types","text":"<p>You can filter operations using several criteria types:</p>"},{"location":"using/configuration/#path","title":"Path","text":"<p>Matches the operation's URL path:</p> <pre><code>[[operations]]\ninclude-path = \"/users/{id}\"\ngeneration.max-examples = 150\n</code></pre>"},{"location":"using/configuration/#method","title":"Method","text":"<p>Matches the HTTP method (GET, POST, PUT, etc.):</p> <pre><code>[[operations]]\ninclude-method = \"POST\"\nrequest-timeout = 3.0\n</code></pre>"},{"location":"using/configuration/#name","title":"Name","text":"<p>Matches the operation's name, which varies by specification:</p> <ul> <li>For OpenAPI: <code>METHOD /path</code> (e.g., <code>GET /users</code>)</li> <li>For GraphQL: <code>Type.field</code> (e.g., <code>Query.getUser</code>)</li> </ul> <pre><code>[[operations]]\ninclude-name = \"GET /users\"\ngeneration.max-examples = 200\n\n[[operations]]\ninclude-name = \"Query.getUser\"  # For GraphQL\ngeneration.max-examples = 200\n</code></pre>"},{"location":"using/configuration/#tag","title":"Tag","text":"<p>Matches operations with specific tags defined in the API specification:</p> <pre><code>[[operations]]\ninclude-tag = \"payment\"\ngeneration.max-examples = 150\nrate-limit = \"20/s\"\n</code></pre>"},{"location":"using/configuration/#operation-id","title":"Operation ID","text":"<p>Matches the <code>operationId</code> field in OpenAPI specifications:</p> <pre><code>[[operations]]\ninclude-operation-id = \"getUserById\"\ngeneration.max-examples = 150\n</code></pre>"},{"location":"using/configuration/#filtering-with-regular-expressions","title":"Filtering with Regular Expressions","text":"<p>Add <code>-regex</code> suffix to any filter type to use regular expression patterns:</p> <pre><code>[[operations]]\ninclude-path-regex = \"/(users|orders)/\"\ngeneration.max-examples = 150\n\n[[operations]]\ninclude-method-regex = \"(POST|PUT|PATCH)\"\nrequest-timeout = 3.0\n\n[[operations]]\ninclude-operation-id-regex = \".*User.*\"\nchecks.not_a_server_error.enabled = false\n</code></pre>"},{"location":"using/configuration/#exclusion-filters","title":"Exclusion Filters","text":"<p>Use <code>exclude-</code> prefix to skip operations matching specific criteria:</p> <pre><code>[[operations]]\nexclude-path = \"/internal/status\"\nenabled = false\n\n[[operations]]\nexclude-tag = \"deprecated\"\nenabled = false\n</code></pre>"},{"location":"using/configuration/#combining-multiple-criteria","title":"Combining Multiple Criteria","text":"<p>You can combine multiple criteria within a single configuration entry:</p> <pre><code>[[operations]]\ninclude-method = \"POST\"\n# include-tag = \"users\"\nrequest-timeout = 3.0\n</code></pre> <p>All criteria must match for the configuration to apply.</p>"},{"location":"using/configuration/#advanced-filtering-with-expressions","title":"Advanced Filtering with Expressions","text":"<p>For more precise control, Schemathesis supports targeting operations using JSONPath-like expressions that query specific fields within operation definitions:</p> <pre><code>[[operations]]\ninclude-by = \"tags/0 == 'user'\"\ngeneration.max-examples = 150\n\n[[operations]]\ninclude-by = \"operationId == null\"\nenabled = false\n\n[[operations]]\nexclude-by = \"responses/200/description != 'Success'\"\nchecks.response_schema_conformance.enabled = false\n</code></pre> <p>Include-by and exclude-by expressions follow the pattern <code>&lt;json-pointer&gt; &lt;operator&gt; &lt;value&gt;</code> where:</p> <ul> <li><code>&lt;json-pointer&gt;</code> is a path to a field in the operation definition</li> <li><code>&lt;operator&gt;</code> is either <code>==</code> (equals) or <code>!=</code> (not equals)</li> <li><code>&lt;value&gt;</code> can be a string, number, boolean, null, array, or object</li> </ul> <p>This is particularly useful for filtering by operation metadata or extension fields.</p>"},{"location":"using/configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>When multiple configuration entries match an operation:</p> <ol> <li>Earlier entries take precedence over later entries in the configuration file</li> <li>If multiple criteria are specified within one entry, all must match for the configuration to apply</li> <li>Exclusion takes precedence over inclusion when at the same level</li> </ol> <p>This allows for granular control by ordering your configuration appropriately.</p>"},{"location":"using/configuration/#operation-specific-authentication","title":"Operation-specific Authentication","text":"<p>If you'd like to override auth for some API operations you can specify the <code>auth</code> key</p> <pre><code>[[operations]]\ninclude-name = \"POST /orders\"\nauth = { basic = { username = \"${USERNAME}\", password = \"${PASSWORD}\" } }\n</code></pre>"},{"location":"using/configuration/#phase-specific-settings-for-operations","title":"Phase-Specific Settings for Operations","text":"<p>Configure phase-specific settings within individual operations for fine-grained control over each phase's behavior:</p> <pre><code>[[operations]]\ninclude-name = \"GET /users\"\n# Default settings for this operation\ngeneration.max-examples = 100\nrequest-timeout = 5.0\n\n# Phase-specific overrides for this operation\n# Increase examples for fuzzing\nphases.fuzzing.generation.max-examples = 200 \n# Reduce examples for stateful tests\nphases.stateful.generation.max-examples = 30\n# Disable a check for examples tests\nphases.examples.checks.not_a_server_error.enabled = false\n</code></pre>"},{"location":"using/configuration/#resolution-order-for-phase-operation-settings","title":"Resolution Order for Phase-Operation Settings","text":"<p>When both operation-level and phase-level settings are defined, Schemathesis applies them in the following order:</p> <ul> <li>Operation-specific phase settings</li> <li>Operation (e.g., <code>[[operations]]</code>)</li> <li>Phase (e.g., <code>[phases.fuzzing]</code>)</li> <li>Global</li> </ul>"},{"location":"using/configuration/#parameter-overrides","title":"Parameter Overrides","text":"<p>Schemathesis allows you overriding API operation parameters for better test case control.</p>"},{"location":"using/configuration/#operation-specific-parameters","title":"Operation-Specific Parameters","text":"<p>Set parameter values for specific operations:</p> <pre><code>[[operations]]\ninclude-name = \"GET /users/{user_id}\"\n# Fixed value\nparameters = { user_id = 42 }\n</code></pre> <pre><code>[[operations]]\ninclude-name = \"GET /users/{user_id}\"\n# Multiple values for random selection\nparameters = { user_id = [1, 42, 499] }\n</code></pre> <pre><code>[[operations]]\ninclude-name = \"GET /users/{user_id}\"\n# Using an environment variable\nparameters = { user_id = \"${USER_ID}\" }\n</code></pre> <pre><code>[[operations]]\ninclude-name = \"GET /users/{user_id}\"\n# Disambiguate parameters with the same name\nparameters = { \"path.user_id\" = 42, \"query.user_id\" = 100 }\n</code></pre>"},{"location":"using/configuration/#global-parameter-overrides","title":"Global Parameter Overrides","text":"<p>Apply parameters across all operations:</p> <pre><code>[parameters]\napi_version = \"v2\"\nlimit = 50\noffset = 0\n</code></pre> <p>These values will only be used if an API operation uses parameters with those names.</p>"},{"location":"using/configuration/#parameter-resolution-order","title":"Parameter Resolution Order","text":"<p>Schemathesis resolves parameter values in this order:</p> <ul> <li>Operation overrides</li> <li>Global overrides</li> <li>Generated</li> </ul>"},{"location":"using/configuration/#parameter-type-disambiguation","title":"Parameter Type Disambiguation","text":"<p>When parameters share the same name, prefix them to indicate their location:</p> <pre><code>[parameters]\n\"path.id\" = 42                      # Path parameter\n\"query.id\" = 100                    # Query parameter\n\"header.X-API-Version\" = \"2.0\"      # Header parameter\n\"cookie.session\" = \"${SESSION_ID}\"  # Cookie parameter\n</code></pre>"},{"location":"using/configuration/#using-parameter-arrays","title":"Using Parameter Arrays","text":"<p>Provide an array of values; Schemathesis will randomly select one per test case:</p> <pre><code>[[operations]]\ninclude-name = \"GET /users\"\nparameters = { role = [\"admin\", \"user\", \"guest\"] }\n</code></pre> <p>The example above distributes the specified roles across test cases.</p>"},{"location":"using/configuration/#multi-project-configuration","title":"Multi-Project Configuration","text":"<p>Schemathesis lets you configure multiple API projects in one file\u2014a handy feature for testing related APIs or different API versions.</p>"},{"location":"using/configuration/#defining-projects","title":"Defining Projects","text":"<p>Define projects in <code>[[project]]</code> tables by matching the API's title:</p> <pre><code>[[project]]\n# Projects are matched by the API schema's `info.title``\ntitle = \"Payment Processing API\"\nbase-url = \"https://payments.example.com\"\n</code></pre> <p>Schemathesis checks the <code>info.title</code> field of the API schema to apply the corresponding project settings.</p>"},{"location":"using/configuration/#project-specific-settings","title":"Project-Specific Settings","text":"<p>Override global defaults with project-specific settings:</p> <pre><code>[[project]]\ntitle = \"Payment Processing API\"\nbase-url = \"https://payments.example.com\"\nworkers = 4\ngeneration.max-examples = 200\nhooks = \"test.config.hooks.example\"\n\n[[project]]\ntitle = \"User Management API\"\nbase-url = \"https://users.example.com\"\nworkers = 2\n</code></pre>"},{"location":"using/configuration/#project-specific-operations","title":"Project-Specific Operations","text":"<p>Customize operations within a project:</p> <pre><code>[[project]]\ntitle = \"Payment Processing API\"\n\n[[project.operations]]\ninclude-name = \"POST /payments\"\ngeneration.max-examples = 80\nheaders = { \"X-Idempotency-Key\" = \"${IDEMPOTENCY_KEY}\" }\n\n[[project.operations]]\ninclude-tag = \"slow\"\nrequest-timeout = 10.0\n</code></pre>"},{"location":"using/configuration/#configuration-resolution","title":"Configuration Resolution","text":"<p>When using projects, settings are applied in this order:</p> <ul> <li>Operation-specific settings within the project</li> <li>Project-level settings</li> <li>Default operation settings (unprefixed)</li> <li>Global settings</li> </ul>"},{"location":"using/configuration/#example-complete-multi-project-configuration","title":"Example: Complete Multi-Project Configuration","text":"<pre><code># Global defaults\ngeneration.max-examples = 50\nworkers = 2\n\n[[project]]\ntitle = \"Payment Processing API\"\nbase-url = \"https://payments.example.com\"\ngeneration.max-examples = 100\n\n# Operations for payments\n[[project.operations]]\ninclude-name = \"POST /payments\"\ngeneration.max-examples = 200\nparameters = { amount = [10, 100, 1000] }\nchecks.positive_data_acceptance.expected-statuses = [200, 201]\n\n# Users project settings\n[[project]]\ntitle = \"User Management API\"\nbase-url = \"https://users.example.com\"\n</code></pre> <p>With this setup, each project uses its own settings while sharing defaults.</p>"},{"location":"using/configuration/#configuration-overrides","title":"Configuration Overrides","text":"<p>While the configuration file provides default settings, you can override most them via CLI options.</p>"},{"location":"using/configuration/#cli-overrides","title":"CLI Overrides","text":"<p>Command-line arguments take precedence over configuration file settings:</p> <pre><code># Override the max-examples setting\nst run --max-examples=300 http://api.example.com/openapi.json\n\n# Override phases\nst run --phases=examples,fuzzing http://api.example.com/openapi.json\n\n# Override check settings\nst run --checks=not_a_server_error http://api.example.com/openapi.json\n</code></pre>"}]}